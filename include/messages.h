/* Automatically generated by gen_messages from /home/qq/paparazzi/conf/messages.xml */
/* Version v5.8.1_stable-0-ga7c97e1 */
/* Please DO NOT EDIT */
/* Macros to send and receive messages of class telemetry */
#ifndef _VAR_MESSAGES_telemetry_H_
#define _VAR_MESSAGES_telemetry_H_
#include "subsystems/datalink/transport.h"
#include "mcu_periph/link_device.h"
#include "generated/airframe.h"
#if DOWNLINK
#define DL_AUTOPILOT_VERSION 1
#define PPRZ_MSG_ID_AUTOPILOT_VERSION 1
#define DL_ALIVE 2
#define PPRZ_MSG_ID_ALIVE 2
#define DL_PONG 3
#define PPRZ_MSG_ID_PONG 3
#define DL_TAKEOFF 4
#define PPRZ_MSG_ID_TAKEOFF 4
#define DL_ARDRONE_NAVDATA 5
#define PPRZ_MSG_ID_ARDRONE_NAVDATA 5
#define DL_ATTITUDE 6
#define PPRZ_MSG_ID_ATTITUDE 6
#define DL_IR_SENSORS 7
#define PPRZ_MSG_ID_IR_SENSORS 7
#define DL_GPS 8
#define PPRZ_MSG_ID_GPS 8
#define DL_NAVIGATION_REF 9
#define PPRZ_MSG_ID_NAVIGATION_REF 9
#define DL_NAVIGATION 10
#define PPRZ_MSG_ID_NAVIGATION 10
#define DL_PPRZ_MODE 11
#define PPRZ_MSG_ID_PPRZ_MODE 11
#define DL_BAT 12
#define PPRZ_MSG_ID_BAT 12
#define DL_DEBUG_MCU_LINK 13
#define PPRZ_MSG_ID_DEBUG_MCU_LINK 13
#define DL_CALIBRATION 14
#define PPRZ_MSG_ID_CALIBRATION 14
#define DL_SETTINGS 15
#define PPRZ_MSG_ID_SETTINGS 15
#define DL_DESIRED 16
#define PPRZ_MSG_ID_DESIRED 16
#define DL_GPS_SOL 17
#define PPRZ_MSG_ID_GPS_SOL 17
#define DL_ADC_GENERIC 18
#define PPRZ_MSG_ID_ADC_GENERIC 18
#define DL_TEST_FORMAT 19
#define PPRZ_MSG_ID_TEST_FORMAT 19
#define DL_CAM 20
#define PPRZ_MSG_ID_CAM 20
#define DL_CIRCLE 21
#define PPRZ_MSG_ID_CIRCLE 21
#define DL_SEGMENT 22
#define PPRZ_MSG_ID_SEGMENT 22
#define DL_VECTORNAV_INFO 23
#define PPRZ_MSG_ID_VECTORNAV_INFO 23
#define DL_SVINFO 25
#define PPRZ_MSG_ID_SVINFO 25
#define DL_DEBUG 26
#define PPRZ_MSG_ID_DEBUG 26
#define DL_SURVEY 27
#define PPRZ_MSG_ID_SURVEY 27
#define DL_WC_RSSI 28
#define PPRZ_MSG_ID_WC_RSSI 28
#define DL_RANGEFINDER 29
#define PPRZ_MSG_ID_RANGEFINDER 29
#define DL_DATALINK_REPORT 30
#define PPRZ_MSG_ID_DATALINK_REPORT 30
#define DL_DL_VALUE 31
#define PPRZ_MSG_ID_DL_VALUE 31
#define DL_MARK 32
#define PPRZ_MSG_ID_MARK 32
#define DL_SYS_MON 33
#define PPRZ_MSG_ID_SYS_MON 33
#define DL_MOTOR 34
#define PPRZ_MSG_ID_MOTOR 34
#define DL_WP_MOVED 35
#define PPRZ_MSG_ID_WP_MOVED 35
#define DL_MKK 36
#define PPRZ_MSG_ID_MKK 36
#define DL_ENERGY 37
#define PPRZ_MSG_ID_ENERGY 37
#define DL_BARO_BMP85_CALIB 38
#define PPRZ_MSG_ID_BARO_BMP85_CALIB 38
#define DL_BARO_BMP85 39
#define PPRZ_MSG_ID_BARO_BMP85 39
#define DL_SPEED_LOOP 40
#define PPRZ_MSG_ID_SPEED_LOOP 40
#define DL_ALT_KALMAN 41
#define PPRZ_MSG_ID_ALT_KALMAN 41
#define DL_ESTIMATOR 42
#define PPRZ_MSG_ID_ESTIMATOR 42
#define DL_TUNE_ROLL 43
#define PPRZ_MSG_ID_TUNE_ROLL 43
#define DL_BARO_MS5534A 44
#define PPRZ_MSG_ID_BARO_MS5534A 44
#define DL_PRESSURE 45
#define PPRZ_MSG_ID_PRESSURE 45
#define DL_BARO_WORDS 46
#define PPRZ_MSG_ID_BARO_WORDS 46
#define DL_WP_MOVED_LLA 47
#define PPRZ_MSG_ID_WP_MOVED_LLA 47
#define DL_CHRONO 48
#define PPRZ_MSG_ID_CHRONO 48
#define DL_WP_MOVED_ENU 49
#define PPRZ_MSG_ID_WP_MOVED_ENU 49
#define DL_WINDTURBINE_STATUS_ 50
#define PPRZ_MSG_ID_WINDTURBINE_STATUS_ 50
#define DL_RC_3CH_ 51
#define PPRZ_MSG_ID_RC_3CH_ 51
#define DL_MPPT 52
#define PPRZ_MSG_ID_MPPT 52
#define DL_DEBUG_IR_I2C 53
#define PPRZ_MSG_ID_DEBUG_IR_I2C 53
#define DL_AIRSPEED 54
#define PPRZ_MSG_ID_AIRSPEED 54
#define DL_XSENS 55
#define PPRZ_MSG_ID_XSENS 55
#define DL_BARO_ETS 56
#define PPRZ_MSG_ID_BARO_ETS 56
#define DL_AIRSPEED_ETS 57
#define PPRZ_MSG_ID_AIRSPEED_ETS 57
#define DL_PBN 58
#define PPRZ_MSG_ID_PBN 58
#define DL_GPS_LLA 59
#define PPRZ_MSG_ID_GPS_LLA 59
#define DL_H_CTL_A 60
#define PPRZ_MSG_ID_H_CTL_A 60
#define DL_TURB_PRESSURE_RAW 61
#define PPRZ_MSG_ID_TURB_PRESSURE_RAW 61
#define DL_TURB_PRESSURE_VOLTAGE 62
#define PPRZ_MSG_ID_TURB_PRESSURE_VOLTAGE 62
#define DL_CAM_POINT 63
#define PPRZ_MSG_ID_CAM_POINT 63
#define DL_DC_INFO 64
#define PPRZ_MSG_ID_DC_INFO 64
#define DL_AMSYS_BARO 65
#define PPRZ_MSG_ID_AMSYS_BARO 65
#define DL_AMSYS_AIRSPEED 66
#define PPRZ_MSG_ID_AMSYS_AIRSPEED 66
#define DL_FLIGHT_BENCHMARK 67
#define PPRZ_MSG_ID_FLIGHT_BENCHMARK 67
#define DL_MPL3115_BARO 68
#define PPRZ_MSG_ID_MPL3115_BARO 68
#define DL_AOA 69
#define PPRZ_MSG_ID_AOA 69
#define DL_XTEND_RSSI 70
#define PPRZ_MSG_ID_XTEND_RSSI 70
#define DL_SUPERBITRF 72
#define PPRZ_MSG_ID_SUPERBITRF 72
#define DL_GX3_INFO 73
#define PPRZ_MSG_ID_GX3_INFO 73
#define DL_EXPLAIN 74
#define PPRZ_MSG_ID_EXPLAIN 74
#define DL_VIDEO_TELEMETRY 75
#define PPRZ_MSG_ID_VIDEO_TELEMETRY 75
#define DL_VF_UPDATE 76
#define PPRZ_MSG_ID_VF_UPDATE 76
#define DL_VF_PREDICT 77
#define PPRZ_MSG_ID_VF_PREDICT 77
#define DL_INV_FILTER 78
#define PPRZ_MSG_ID_INV_FILTER 78
#define DL_MISSION_STATUS 79
#define PPRZ_MSG_ID_MISSION_STATUS 79
#define DL_CROSS_TRACK_ERROR 80
#define PPRZ_MSG_ID_CROSS_TRACK_ERROR 80
#define DL_GENERIC_COM 81
#define PPRZ_MSG_ID_GENERIC_COM 81
#define DL_FORMATION_SLOT_TM 82
#define PPRZ_MSG_ID_FORMATION_SLOT_TM 82
#define DL_FORMATION_STATUS_TM 83
#define PPRZ_MSG_ID_FORMATION_STATUS_TM 83
#define DL_BMP_STATUS 84
#define PPRZ_MSG_ID_BMP_STATUS 84
#define DL_MLX_STATUS 85
#define PPRZ_MSG_ID_MLX_STATUS 85
#define DL_TMP_STATUS 86
#define PPRZ_MSG_ID_TMP_STATUS 86
#define DL_WIND_INFO_RET 87
#define PPRZ_MSG_ID_WIND_INFO_RET 87
#define DL_SCP_STATUS 88
#define PPRZ_MSG_ID_SCP_STATUS 88
#define DL_SHT_STATUS 89
#define PPRZ_MSG_ID_SHT_STATUS 89
#define DL_ENOSE_STATUS 90
#define PPRZ_MSG_ID_ENOSE_STATUS 90
#define DL_DPICCO_STATUS 91
#define PPRZ_MSG_ID_DPICCO_STATUS 91
#define DL_ANTENNA_DEBUG 92
#define PPRZ_MSG_ID_ANTENNA_DEBUG 92
#define DL_ANTENNA_STATUS 93
#define PPRZ_MSG_ID_ANTENNA_STATUS 93
#define DL_MOTOR_BENCH_STATUS 94
#define PPRZ_MSG_ID_MOTOR_BENCH_STATUS 94
#define DL_MOTOR_BENCH_STATIC 95
#define PPRZ_MSG_ID_MOTOR_BENCH_STATIC 95
#define DL_HIH_STATUS 96
#define PPRZ_MSG_ID_HIH_STATUS 96
#define DL_TEMT_STATUS 97
#define PPRZ_MSG_ID_TEMT_STATUS 97
#define DL_GP2Y_STATUS 98
#define PPRZ_MSG_ID_GP2Y_STATUS 98
#define DL_SHT_I2C_SERIAL 99
#define PPRZ_MSG_ID_SHT_I2C_SERIAL 99
#define DL_PPM 100
#define PPRZ_MSG_ID_PPM 100
#define DL_RC 101
#define PPRZ_MSG_ID_RC 101
#define DL_COMMANDS 102
#define PPRZ_MSG_ID_COMMANDS 102
#define DL_FBW_STATUS 103
#define PPRZ_MSG_ID_FBW_STATUS 103
#define DL_ADC 104
#define PPRZ_MSG_ID_ADC 104
#define DL_ACTUATORS 105
#define PPRZ_MSG_ID_ACTUATORS 105
#define DL_BLUEGIGA 106
#define PPRZ_MSG_ID_BLUEGIGA 106
#define DL_MULTIGAZE_METERS 109
#define PPRZ_MSG_ID_MULTIGAZE_METERS 109
#define DL_DC_SHOT 110
#define PPRZ_MSG_ID_DC_SHOT 110
#define DL_TEST_BOARD_RESULTS 111
#define PPRZ_MSG_ID_TEST_BOARD_RESULTS 111
#define DL_MLX_SERIAL 113
#define PPRZ_MSG_ID_MLX_SERIAL 113
#define DL_PAYLOAD 114
#define PPRZ_MSG_ID_PAYLOAD 114
#define DL_HTM_STATUS 115
#define PPRZ_MSG_ID_HTM_STATUS 115
#define DL_BARO_MS5611 116
#define PPRZ_MSG_ID_BARO_MS5611 116
#define DL_MS5611_COEFF 117
#define PPRZ_MSG_ID_MS5611_COEFF 117
#define DL_ATMOSPHERE_CHARGE 118
#define PPRZ_MSG_ID_ATMOSPHERE_CHARGE 118
#define DL_SOLAR_RADIATION 119
#define PPRZ_MSG_ID_SOLAR_RADIATION 119
#define DL_TCAS_TA 120
#define PPRZ_MSG_ID_TCAS_TA 120
#define DL_TCAS_RA 121
#define PPRZ_MSG_ID_TCAS_RA 121
#define DL_TCAS_RESOLVED 122
#define PPRZ_MSG_ID_TCAS_RESOLVED 122
#define DL_TCAS_DEBUG 123
#define PPRZ_MSG_ID_TCAS_DEBUG 123
#define DL_POTENTIAL 124
#define PPRZ_MSG_ID_POTENTIAL 124
#define DL_VERTICAL_ENERGY 125
#define PPRZ_MSG_ID_VERTICAL_ENERGY 125
#define DL_TEMP_TCOUPLE 126
#define PPRZ_MSG_ID_TEMP_TCOUPLE 126
#define DL_SHT_I2C_STATUS 127
#define PPRZ_MSG_ID_SHT_I2C_STATUS 127
#define DL_CAMERA_SNAPSHOT 128
#define PPRZ_MSG_ID_CAMERA_SNAPSHOT 128
#define DL_TIMESTAMP 129
#define PPRZ_MSG_ID_TIMESTAMP 129
#define DL_STAB_ATTITUDE_FLOAT 130
#define PPRZ_MSG_ID_STAB_ATTITUDE_FLOAT 130
#define DL_IMU_GYRO_SCALED 131
#define PPRZ_MSG_ID_IMU_GYRO_SCALED 131
#define DL_IMU_ACCEL_SCALED 132
#define PPRZ_MSG_ID_IMU_ACCEL_SCALED 132
#define DL_IMU_MAG_SCALED 133
#define PPRZ_MSG_ID_IMU_MAG_SCALED 133
#define DL_FILTER 134
#define PPRZ_MSG_ID_FILTER 134
#define DL_FILTER2 135
#define PPRZ_MSG_ID_FILTER2 135
#define DL_RATE_LOOP 136
#define PPRZ_MSG_ID_RATE_LOOP 136
#define DL_FILTER_ALIGNER 137
#define PPRZ_MSG_ID_FILTER_ALIGNER 137
#define DL_AIRSPEED_MS45XX 138
#define PPRZ_MSG_ID_AIRSPEED_MS45XX 138
#define DL_FILTER_COR 139
#define PPRZ_MSG_ID_FILTER_COR 139
#define DL_STAB_ATTITUDE_INT 140
#define PPRZ_MSG_ID_STAB_ATTITUDE_INT 140
#define DL_STAB_ATTITUDE_REF_INT 141
#define PPRZ_MSG_ID_STAB_ATTITUDE_REF_INT 141
#define DL_STAB_ATTITUDE_REF_FLOAT 142
#define PPRZ_MSG_ID_STAB_ATTITUDE_REF_FLOAT 142
#define DL_ROTORCRAFT_CMD 143
#define PPRZ_MSG_ID_ROTORCRAFT_CMD 143
#define DL_GUIDANCE_H_INT 144
#define PPRZ_MSG_ID_GUIDANCE_H_INT 144
#define DL_VERT_LOOP 145
#define PPRZ_MSG_ID_VERT_LOOP 145
#define DL_HOVER_LOOP 146
#define PPRZ_MSG_ID_HOVER_LOOP 146
#define DL_ROTORCRAFT_FP 147
#define PPRZ_MSG_ID_ROTORCRAFT_FP 147
#define DL_TEMP_ADC 148
#define PPRZ_MSG_ID_TEMP_ADC 148
#define DL_GUIDANCE_H_REF_INT 149
#define PPRZ_MSG_ID_GUIDANCE_H_REF_INT 149
#define DL_ROTORCRAFT_TUNE_HOVER 150
#define PPRZ_MSG_ID_ROTORCRAFT_TUNE_HOVER 150
#define DL_INS_Z 151
#define PPRZ_MSG_ID_INS_Z 151
#define DL_PCAP01_STATUS 152
#define PPRZ_MSG_ID_PCAP01_STATUS 152
#define DL_GEIGER_COUNTER 153
#define PPRZ_MSG_ID_GEIGER_COUNTER 153
#define DL_INS_REF 154
#define PPRZ_MSG_ID_INS_REF 154
#define DL_GPS_INT 155
#define PPRZ_MSG_ID_GPS_INT 155
#define DL_AHRS_EULER_INT 156
#define PPRZ_MSG_ID_AHRS_EULER_INT 156
#define DL_AHRS_QUAT_INT 157
#define PPRZ_MSG_ID_AHRS_QUAT_INT 157
#define DL_AHRS_RMAT_INT 158
#define PPRZ_MSG_ID_AHRS_RMAT_INT 158
#define DL_ROTORCRAFT_NAV_STATUS 159
#define PPRZ_MSG_ID_ROTORCRAFT_NAV_STATUS 159
#define DL_ROTORCRAFT_RADIO_CONTROL 160
#define PPRZ_MSG_ID_ROTORCRAFT_RADIO_CONTROL 160
#define DL_VFF_EXTENDED 161
#define PPRZ_MSG_ID_VFF_EXTENDED 161
#define DL_VFF 162
#define PPRZ_MSG_ID_VFF 162
#define DL_GEO_MAG 163
#define PPRZ_MSG_ID_GEO_MAG 163
#define DL_HFF 164
#define PPRZ_MSG_ID_HFF 164
#define DL_HFF_DBG 165
#define PPRZ_MSG_ID_HFF_DBG 165
#define DL_HFF_GPS 166
#define PPRZ_MSG_ID_HFF_GPS 166
#define DL_INS_SONAR 167
#define PPRZ_MSG_ID_INS_SONAR 167
#define DL_ROTORCRAFT_CAM 168
#define PPRZ_MSG_ID_ROTORCRAFT_CAM 168
#define DL_AHRS_REF_QUAT 169
#define PPRZ_MSG_ID_AHRS_REF_QUAT 169
#define DL_EKF7_XHAT 170
#define PPRZ_MSG_ID_EKF7_XHAT 170
#define DL_EKF7_Y 171
#define PPRZ_MSG_ID_EKF7_Y 171
#define DL_EKF7_P_DIAG 172
#define PPRZ_MSG_ID_EKF7_P_DIAG 172
#define DL_AHRS_EULER 173
#define PPRZ_MSG_ID_AHRS_EULER 173
#define DL_AHRS_MEASUREMENT_EULER 174
#define PPRZ_MSG_ID_AHRS_MEASUREMENT_EULER 174
#define DL_WT 175
#define PPRZ_MSG_ID_WT 175
#define DL_CSC_CAN_DEBUG 176
#define PPRZ_MSG_ID_CSC_CAN_DEBUG 176
#define DL_CSC_CAN_MSG 177
#define PPRZ_MSG_ID_CSC_CAN_MSG 177
#define DL_AHRS_GYRO_BIAS_INT 178
#define PPRZ_MSG_ID_AHRS_GYRO_BIAS_INT 178
#define DL_FLOW_AP_OTF 179
#define PPRZ_MSG_ID_FLOW_AP_OTF 179
#define DL_FMS_TIME 180
#define PPRZ_MSG_ID_FMS_TIME 180
#define DL_LOADCELL 181
#define PPRZ_MSG_ID_LOADCELL 181
#define DL_FLA_DEBUG 182
#define PPRZ_MSG_ID_FLA_DEBUG 182
#define DL_BLMC_FAULT_STATUS 183
#define PPRZ_MSG_ID_BLMC_FAULT_STATUS 183
#define DL_BLMC_SPEEDS 184
#define PPRZ_MSG_ID_BLMC_SPEEDS 184
#define DL_AHRS_DEBUG_QUAT 185
#define PPRZ_MSG_ID_AHRS_DEBUG_QUAT 185
#define DL_BLMC_BUSVOLTS 186
#define PPRZ_MSG_ID_BLMC_BUSVOLTS 186
#define DL_SYSTEM_STATUS 187
#define PPRZ_MSG_ID_SYSTEM_STATUS 187
#define DL_DYNAMIXEL 188
#define PPRZ_MSG_ID_DYNAMIXEL 188
#define DL_RMAT_DEBUG 189
#define PPRZ_MSG_ID_RMAT_DEBUG 189
#define DL_SIMPLE_COMMANDS 190
#define PPRZ_MSG_ID_SIMPLE_COMMANDS 190
#define DL_VANE_SENSOR 191
#define PPRZ_MSG_ID_VANE_SENSOR 191
#define DL_CONTROLLER_GAINS 192
#define PPRZ_MSG_ID_CONTROLLER_GAINS 192
#define DL_AHRS_LKF 193
#define PPRZ_MSG_ID_AHRS_LKF 193
#define DL_AHRS_LKF_DEBUG 194
#define PPRZ_MSG_ID_AHRS_LKF_DEBUG 194
#define DL_AHRS_LKF_ACC_DBG 195
#define PPRZ_MSG_ID_AHRS_LKF_ACC_DBG 195
#define DL_AHRS_LKF_MAG_DBG 196
#define PPRZ_MSG_ID_AHRS_LKF_MAG_DBG 196
#define DL_NPS_SENSORS_SCALED 197
#define PPRZ_MSG_ID_NPS_SENSORS_SCALED 197
#define DL_INS 198
#define PPRZ_MSG_ID_INS 198
#define DL_GPS_ERROR 199
#define PPRZ_MSG_ID_GPS_ERROR 199
#define DL_IMU_GYRO 200
#define PPRZ_MSG_ID_IMU_GYRO 200
#define DL_IMU_MAG 201
#define PPRZ_MSG_ID_IMU_MAG 201
#define DL_IMU_ACCEL 202
#define PPRZ_MSG_ID_IMU_ACCEL 202
#define DL_IMU_GYRO_RAW 203
#define PPRZ_MSG_ID_IMU_GYRO_RAW 203
#define DL_IMU_ACCEL_RAW 204
#define PPRZ_MSG_ID_IMU_ACCEL_RAW 204
#define DL_IMU_MAG_RAW 205
#define PPRZ_MSG_ID_IMU_MAG_RAW 205
#define DL_IMU_MAG_SETTINGS 206
#define PPRZ_MSG_ID_IMU_MAG_SETTINGS 206
#define DL_IMU_MAG_CURRENT_CALIBRATION 207
#define PPRZ_MSG_ID_IMU_MAG_CURRENT_CALIBRATION 207
#define DL_UART_ERRORS 208
#define PPRZ_MSG_ID_UART_ERRORS 208
#define DL_IMU_GYRO_LP 209
#define PPRZ_MSG_ID_IMU_GYRO_LP 209
#define DL_IMU_PRESSURE 210
#define PPRZ_MSG_ID_IMU_PRESSURE 210
#define DL_IMU_HS_GYRO 211
#define PPRZ_MSG_ID_IMU_HS_GYRO 211
#define DL_TEST_PASSTHROUGH_STATUS 212
#define PPRZ_MSG_ID_TEST_PASSTHROUGH_STATUS 212
#define DL_TUNE_VERT 213
#define PPRZ_MSG_ID_TUNE_VERT 213
#define DL_MF_DAQ_STATE 214
#define PPRZ_MSG_ID_MF_DAQ_STATE 214
#define DL_INFO_MSG 215
#define PPRZ_MSG_ID_INFO_MSG 215
#define DL_STAB_ATTITUDE_INDI 216
#define PPRZ_MSG_ID_STAB_ATTITUDE_INDI 216
#define DL_BEBOP_ACTUATORS 218
#define PPRZ_MSG_ID_BEBOP_ACTUATORS 218
#define DL_WEATHER 219
#define PPRZ_MSG_ID_WEATHER 219
#define DL_IMU_TURNTABLE 220
#define PPRZ_MSG_ID_IMU_TURNTABLE 220
#define DL_BARO_RAW 221
#define PPRZ_MSG_ID_BARO_RAW 221
#define DL_AIR_DATA 222
#define PPRZ_MSG_ID_AIR_DATA 222
#define DL_AMSL 223
#define PPRZ_MSG_ID_AMSL 223
#define DL_VIDEO_SYNC 225
#define PPRZ_MSG_ID_VIDEO_SYNC 225
#define DL_PERIODIC_TELEMETRY_ERR 226
#define PPRZ_MSG_ID_PERIODIC_TELEMETRY_ERR 226
#define DL_TIME 227
#define PPRZ_MSG_ID_TIME 227
#define DL_OPTIC_FLOW_EST 228
#define PPRZ_MSG_ID_OPTIC_FLOW_EST 228
#define DL_STEREO_IMG 229
#define PPRZ_MSG_ID_STEREO_IMG 229
#define DL_ROTORCRAFT_STATUS 231
#define PPRZ_MSG_ID_ROTORCRAFT_STATUS 231
#define DL_STATE_FILTER_STATUS 232
#define PPRZ_MSG_ID_STATE_FILTER_STATUS 232
#define DL_PX4FLOW 233
#define PPRZ_MSG_ID_PX4FLOW 233
#define DL_OPTICFLOW 234
#define PPRZ_MSG_ID_OPTICFLOW 234
#define DL_VISUALTARGET 235
#define PPRZ_MSG_ID_VISUALTARGET 235
#define DL_SONAR 236
#define PPRZ_MSG_ID_SONAR 236
#define DL_PAYLOAD_FLOAT 237
#define PPRZ_MSG_ID_PAYLOAD_FLOAT 237
#define DL_NPS_POS_LLH 238
#define PPRZ_MSG_ID_NPS_POS_LLH 238
#define DL_NPS_RPMS 239
#define PPRZ_MSG_ID_NPS_RPMS 239
#define DL_NPS_SPEED_POS 240
#define PPRZ_MSG_ID_NPS_SPEED_POS 240
#define DL_NPS_RATE_ATTITUDE 241
#define PPRZ_MSG_ID_NPS_RATE_ATTITUDE 241
#define DL_NPS_GYRO_BIAS 242
#define PPRZ_MSG_ID_NPS_GYRO_BIAS 242
#define DL_NPS_RANGE_METER 243
#define PPRZ_MSG_ID_NPS_RANGE_METER 243
#define DL_NPS_WIND 244
#define PPRZ_MSG_ID_NPS_WIND 244
#define DL_PPRZ_DEBUG 247
#define PPRZ_MSG_ID_PPRZ_DEBUG 247
#define DL_NPS_ACCEL_LTP 248
#define PPRZ_MSG_ID_NPS_ACCEL_LTP 248
#define DL_LOOSE_INS_GPS 249
#define PPRZ_MSG_ID_LOOSE_INS_GPS 249
#define DL_AFL_COEFFS 250
#define PPRZ_MSG_ID_AFL_COEFFS 250
#define DL_I2C_ERRORS 253
#define PPRZ_MSG_ID_I2C_ERRORS 253
#define DL_RDYB_TRAJECTORY 254
#define PPRZ_MSG_ID_RDYB_TRAJECTORY 254
#define DL_HENRY_GNSS 255
#define PPRZ_MSG_ID_HENRY_GNSS 255
#define DL_MSG_telemetry_NB 243

#define DOWNLINK_SEND_AUTOPILOT_VERSION(_trans, _dev, version, nb_desc, desc) pprz_msg_send_AUTOPILOT_VERSION(&((_trans).trans_tx), &((_dev).device), AC_ID, version, nb_desc, desc)
static inline void pprz_msg_send_AUTOPILOT_VERSION(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_version, uint8_t nb_desc, char *_desc) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+1+nb_desc*1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+1+nb_desc*1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+1+nb_desc*1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AUTOPILOT_VERSION, "AUTOPILOT_VERSION");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _version);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_desc);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_CHAR, DL_FORMAT_ARRAY, 1 * nb_desc, (void *) _desc);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ALIVE(_trans, _dev, nb_md5sum, md5sum) pprz_msg_send_ALIVE(&((_trans).trans_tx), &((_dev).device), AC_ID, nb_md5sum, md5sum)
static inline void pprz_msg_send_ALIVE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_md5sum, uint8_t *_md5sum) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_md5sum*1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_md5sum*1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+nb_md5sum*1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ALIVE, "ALIVE");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_md5sum);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_ARRAY, 1 * nb_md5sum, (void *) _md5sum);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_PONG(_trans, _dev) pprz_msg_send_PONG(&((_trans).trans_tx), &((_dev).device), AC_ID)
static inline void pprz_msg_send_PONG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_PONG, "PONG");
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TAKEOFF(_trans, _dev, cpu_time) pprz_msg_send_TAKEOFF(&((_trans).trans_tx), &((_dev).device), AC_ID, cpu_time)
static inline void pprz_msg_send_TAKEOFF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_cpu_time) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TAKEOFF, "TAKEOFF");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _cpu_time);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ARDRONE_NAVDATA(_trans, _dev, taille, nu_trame, ax, ay, az, vx, vy, vz, temperature_acc, temperature_gyro, ultrasound, us_debut_echo, us_fin_echo, us_association_echo, us_distance_echo, us_curve_time, us_curve_value, us_curve_ref, nb_echo, sum_echo, gradient, flag_echo_ini, pressure, temperature_pressure, mx, my, mz, chksum, checksum_errors) pprz_msg_send_ARDRONE_NAVDATA(&((_trans).trans_tx), &((_dev).device), AC_ID, taille, nu_trame, ax, ay, az, vx, vy, vz, temperature_acc, temperature_gyro, ultrasound, us_debut_echo, us_fin_echo, us_association_echo, us_distance_echo, us_curve_time, us_curve_value, us_curve_ref, nb_echo, sum_echo, gradient, flag_echo_ini, pressure, temperature_pressure, mx, my, mz, chksum, checksum_errors)
static inline void pprz_msg_send_ARDRONE_NAVDATA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_taille, uint16_t *_nu_trame, uint16_t *_ax, uint16_t *_ay, uint16_t *_az, int16_t *_vx, int16_t *_vy, int16_t *_vz, uint16_t *_temperature_acc, uint16_t *_temperature_gyro, uint16_t *_ultrasound, uint16_t *_us_debut_echo, uint16_t *_us_fin_echo, uint16_t *_us_association_echo, uint16_t *_us_distance_echo, uint16_t *_us_curve_time, uint16_t *_us_curve_value, uint16_t *_us_curve_ref, uint16_t *_nb_echo, uint32_t *_sum_echo, int16_t *_gradient, uint16_t *_flag_echo_ini, int32_t *_pressure, uint16_t *_temperature_pressure, int16_t *_mx, int16_t *_my, int16_t *_mz, uint16_t *_chksum, uint32_t *_checksum_errors) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+4+2+2+4+2+2+2+2+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+4+2+2+4+2+2+2+2+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+4+2+2+4+2+2+2+2+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ARDRONE_NAVDATA, "ARDRONE_NAVDATA");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _taille);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _nu_trame);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _ax);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _ay);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _az);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _vx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _vy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _vz);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _temperature_acc);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _temperature_gyro);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _ultrasound);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _us_debut_echo);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _us_fin_echo);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _us_association_echo);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _us_distance_echo);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _us_curve_time);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _us_curve_value);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _us_curve_ref);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _nb_echo);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _sum_echo);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _gradient);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _flag_echo_ini);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _pressure);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _temperature_pressure);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _mx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _my);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _mz);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _chksum);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _checksum_errors);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ATTITUDE(_trans, _dev, phi, psi, theta) pprz_msg_send_ATTITUDE(&((_trans).trans_tx), &((_dev).device), AC_ID, phi, psi, theta)
static inline void pprz_msg_send_ATTITUDE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_phi, float *_psi, float *_theta) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ATTITUDE, "ATTITUDE");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _theta);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IR_SENSORS(_trans, _dev, ir1, ir2, longitudinal, lateral, vertical) pprz_msg_send_IR_SENSORS(&((_trans).trans_tx), &((_dev).device), AC_ID, ir1, ir2, longitudinal, lateral, vertical)
static inline void pprz_msg_send_IR_SENSORS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_ir1, int16_t *_ir2, int16_t *_longitudinal, int16_t *_lateral, int16_t *_vertical) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IR_SENSORS, "IR_SENSORS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _ir1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _ir2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _longitudinal);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _lateral);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _vertical);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_GPS(_trans, _dev, mode, utm_east, utm_north, course, alt, speed, climb, week, itow, utm_zone, gps_nb_err) pprz_msg_send_GPS(&((_trans).trans_tx), &((_dev).device), AC_ID, mode, utm_east, utm_north, course, alt, speed, climb, week, itow, utm_zone, gps_nb_err)
static inline void pprz_msg_send_GPS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_mode, int32_t *_utm_east, int32_t *_utm_north, int16_t *_course, int32_t *_alt, uint16_t *_speed, int16_t *_climb, uint16_t *_week, uint32_t *_itow, uint8_t *_utm_zone, uint8_t *_gps_nb_err) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+4+4+2+4+2+2+2+4+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+4+4+2+4+2+2+2+4+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+4+4+2+4+2+2+2+4+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_GPS, "GPS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _mode);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _utm_east);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _utm_north);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _course);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _alt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _speed);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _climb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _week);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _itow);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _utm_zone);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _gps_nb_err);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_NAVIGATION_REF(_trans, _dev, utm_east, utm_north, utm_zone, ground_alt) pprz_msg_send_NAVIGATION_REF(&((_trans).trans_tx), &((_dev).device), AC_ID, utm_east, utm_north, utm_zone, ground_alt)
static inline void pprz_msg_send_NAVIGATION_REF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_utm_east, int32_t *_utm_north, uint8_t *_utm_zone, float *_ground_alt) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+1+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+1+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+1+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_NAVIGATION_REF, "NAVIGATION_REF");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _utm_east);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _utm_north);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _utm_zone);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ground_alt);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_NAVIGATION(_trans, _dev, cur_block, cur_stage, pos_x, pos_y, dist_wp, dist_home, circle_count, oval_count) pprz_msg_send_NAVIGATION(&((_trans).trans_tx), &((_dev).device), AC_ID, cur_block, cur_stage, pos_x, pos_y, dist_wp, dist_home, circle_count, oval_count)
static inline void pprz_msg_send_NAVIGATION(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_cur_block, uint8_t *_cur_stage, float *_pos_x, float *_pos_y, float *_dist_wp, float *_dist_home, uint8_t *_circle_count, uint8_t *_oval_count) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+4+4+4+4+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+4+4+4+4+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+4+4+4+4+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_NAVIGATION, "NAVIGATION");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _cur_block);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _cur_stage);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pos_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pos_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _dist_wp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _dist_home);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _circle_count);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _oval_count);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_PPRZ_MODE(_trans, _dev, ap_mode, ap_gaz, ap_lateral, ap_horizontal, if_calib_mode, mcu1_status) pprz_msg_send_PPRZ_MODE(&((_trans).trans_tx), &((_dev).device), AC_ID, ap_mode, ap_gaz, ap_lateral, ap_horizontal, if_calib_mode, mcu1_status)
static inline void pprz_msg_send_PPRZ_MODE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ap_mode, uint8_t *_ap_gaz, uint8_t *_ap_lateral, uint8_t *_ap_horizontal, uint8_t *_if_calib_mode, uint8_t *_mcu1_status) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1+1+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1+1+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+1+1+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_PPRZ_MODE, "PPRZ_MODE");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ap_mode);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ap_gaz);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ap_lateral);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ap_horizontal);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _if_calib_mode);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _mcu1_status);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_BAT(_trans, _dev, throttle, voltage, amps, flight_time, kill_auto_throttle, block_time, stage_time, energy) pprz_msg_send_BAT(&((_trans).trans_tx), &((_dev).device), AC_ID, throttle, voltage, amps, flight_time, kill_auto_throttle, block_time, stage_time, energy)
static inline void pprz_msg_send_BAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_throttle, uint16_t *_voltage, int16_t *_amps, uint16_t *_flight_time, uint8_t *_kill_auto_throttle, uint16_t *_block_time, uint16_t *_stage_time, int16_t *_energy) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+1+2+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+1+2+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+2+1+2+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_BAT, "BAT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _throttle);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _voltage);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _amps);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _flight_time);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _kill_auto_throttle);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _block_time);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _stage_time);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _energy);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_DEBUG_MCU_LINK(_trans, _dev, i2c_nb_err, i2c_mcu1_nb_err, ppm_rate) pprz_msg_send_DEBUG_MCU_LINK(&((_trans).trans_tx), &((_dev).device), AC_ID, i2c_nb_err, i2c_mcu1_nb_err, ppm_rate)
static inline void pprz_msg_send_DEBUG_MCU_LINK(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_i2c_nb_err, uint8_t *_i2c_mcu1_nb_err, uint8_t *_ppm_rate) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_DEBUG_MCU_LINK, "DEBUG_MCU_LINK");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _i2c_nb_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _i2c_mcu1_nb_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ppm_rate);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_CALIBRATION(_trans, _dev, climb_sum_err, climb_gaz_submode) pprz_msg_send_CALIBRATION(&((_trans).trans_tx), &((_dev).device), AC_ID, climb_sum_err, climb_gaz_submode)
static inline void pprz_msg_send_CALIBRATION(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_climb_sum_err, uint8_t *_climb_gaz_submode) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_CALIBRATION, "CALIBRATION");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _climb_sum_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _climb_gaz_submode);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_SETTINGS(_trans, _dev, slider_1_val, slider_2_val) pprz_msg_send_SETTINGS(&((_trans).trans_tx), &((_dev).device), AC_ID, slider_1_val, slider_2_val)
static inline void pprz_msg_send_SETTINGS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_slider_1_val, float *_slider_2_val) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_SETTINGS, "SETTINGS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _slider_1_val);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _slider_2_val);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_DESIRED(_trans, _dev, roll, pitch, course, x, y, altitude, climb, airspeed) pprz_msg_send_DESIRED(&((_trans).trans_tx), &((_dev).device), AC_ID, roll, pitch, course, x, y, altitude, climb, airspeed)
static inline void pprz_msg_send_DESIRED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_roll, float *_pitch, float *_course, float *_x, float *_y, float *_altitude, float *_climb, float *_airspeed) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_DESIRED, "DESIRED");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _roll);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pitch);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _course);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _altitude);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _climb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _airspeed);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_GPS_SOL(_trans, _dev, Pacc, Sacc, PDOP, numSV) pprz_msg_send_GPS_SOL(&((_trans).trans_tx), &((_dev).device), AC_ID, Pacc, Sacc, PDOP, numSV)
static inline void pprz_msg_send_GPS_SOL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_Pacc, uint32_t *_Sacc, uint16_t *_PDOP, uint8_t *_numSV) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+2+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+2+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+2+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_GPS_SOL, "GPS_SOL");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _Pacc);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _Sacc);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _PDOP);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _numSV);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ADC_GENERIC(_trans, _dev, val1, val2) pprz_msg_send_ADC_GENERIC(&((_trans).trans_tx), &((_dev).device), AC_ID, val1, val2)
static inline void pprz_msg_send_ADC_GENERIC(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_val1, uint16_t *_val2) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ADC_GENERIC, "ADC_GENERIC");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _val1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _val2);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TEST_FORMAT(_trans, _dev, val1, val2) pprz_msg_send_TEST_FORMAT(&((_trans).trans_tx), &((_dev).device), AC_ID, val1, val2)
static inline void pprz_msg_send_TEST_FORMAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, double *_val1, float *_val2) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+8+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+8+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+8+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TEST_FORMAT, "TEST_FORMAT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _val1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _val2);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_CAM(_trans, _dev, phi, theta, target_x, target_y) pprz_msg_send_CAM(&((_trans).trans_tx), &((_dev).device), AC_ID, phi, theta, target_x, target_y)
static inline void pprz_msg_send_CAM(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_phi, int16_t *_theta, int16_t *_target_x, int16_t *_target_y) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_CAM, "CAM");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _target_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _target_y);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_CIRCLE(_trans, _dev, center_east, center_north, radius) pprz_msg_send_CIRCLE(&((_trans).trans_tx), &((_dev).device), AC_ID, center_east, center_north, radius)
static inline void pprz_msg_send_CIRCLE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_center_east, float *_center_north, float *_radius) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_CIRCLE, "CIRCLE");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _center_east);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _center_north);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _radius);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_SEGMENT(_trans, _dev, segment_east_1, segment_north_1, segment_east_2, segment_north_2) pprz_msg_send_SEGMENT(&((_trans).trans_tx), &((_dev).device), AC_ID, segment_east_1, segment_north_1, segment_east_2, segment_north_2)
static inline void pprz_msg_send_SEGMENT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_segment_east_1, float *_segment_north_1, float *_segment_east_2, float *_segment_north_2) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_SEGMENT, "SEGMENT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _segment_east_1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _segment_north_1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _segment_east_2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _segment_north_2);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_VECTORNAV_INFO(_trans, _dev, timestamp, chksm_error, hdr_error, counter, ins_status, ins_err, YprU1, YprU2, YprU3) pprz_msg_send_VECTORNAV_INFO(&((_trans).trans_tx), &((_dev).device), AC_ID, timestamp, chksm_error, hdr_error, counter, ins_status, ins_err, YprU1, YprU2, YprU3)
static inline void pprz_msg_send_VECTORNAV_INFO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_timestamp, uint32_t *_chksm_error, uint32_t *_hdr_error, uint16_t *_counter, uint8_t *_ins_status, uint8_t *_ins_err, float *_YprU1, float *_YprU2, float *_YprU3) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+2+1+1+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+2+1+1+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+2+1+1+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_VECTORNAV_INFO, "VECTORNAV_INFO");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _timestamp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _chksm_error);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _hdr_error);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _counter);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ins_status);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ins_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _YprU1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _YprU2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _YprU3);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_SVINFO(_trans, _dev, chn, SVID, Flags, QI, CNO, Elev, Azim) pprz_msg_send_SVINFO(&((_trans).trans_tx), &((_dev).device), AC_ID, chn, SVID, Flags, QI, CNO, Elev, Azim)
static inline void pprz_msg_send_SVINFO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_chn, uint8_t *_SVID, uint8_t *_Flags, uint8_t *_QI, uint8_t *_CNO, int8_t *_Elev, int16_t *_Azim) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1+1+1+1+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1+1+1+1+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+1+1+1+1+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_SVINFO, "SVINFO");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _chn);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _SVID);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _Flags);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _QI);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _CNO);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT8, DL_FORMAT_SCALAR, 1, (void *) _Elev);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _Azim);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_DEBUG(_trans, _dev, nb_msg, msg) pprz_msg_send_DEBUG(&((_trans).trans_tx), &((_dev).device), AC_ID, nb_msg, msg)
static inline void pprz_msg_send_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_msg, uint8_t *_msg) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_msg*1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_msg*1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+nb_msg*1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_DEBUG, "DEBUG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_msg);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_ARRAY, 1 * nb_msg, (void *) _msg);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_SURVEY(_trans, _dev, east, north, west, south) pprz_msg_send_SURVEY(&((_trans).trans_tx), &((_dev).device), AC_ID, east, north, west, south)
static inline void pprz_msg_send_SURVEY(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_east, float *_north, float *_west, float *_south) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_SURVEY, "SURVEY");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _east);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _north);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _west);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _south);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_WC_RSSI(_trans, _dev, raw_level) pprz_msg_send_WC_RSSI(&((_trans).trans_tx), &((_dev).device), AC_ID, raw_level)
static inline void pprz_msg_send_WC_RSSI(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_raw_level) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_WC_RSSI, "WC_RSSI");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _raw_level);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_RANGEFINDER(_trans, _dev, range, z_dot, z_dot_sum_err, z_dot_setpoint, z_sum_err, z_setpoint, flying) pprz_msg_send_RANGEFINDER(&((_trans).trans_tx), &((_dev).device), AC_ID, range, z_dot, z_dot_sum_err, z_dot_setpoint, z_sum_err, z_setpoint, flying)
static inline void pprz_msg_send_RANGEFINDER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_range, float *_z_dot, float *_z_dot_sum_err, float *_z_dot_setpoint, float *_z_sum_err, float *_z_setpoint, uint8_t *_flying) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4+4+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4+4+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4+4+4+4+4+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_RANGEFINDER, "RANGEFINDER");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _range);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _z_dot);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _z_dot_sum_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _z_dot_setpoint);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _z_sum_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _z_setpoint);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _flying);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_DATALINK_REPORT(_trans, _dev, uplink_lost_time, uplink_nb_msgs, downlink_nb_msgs, downlink_rate, uplink_rate, downlink_ovrn) pprz_msg_send_DATALINK_REPORT(&((_trans).trans_tx), &((_dev).device), AC_ID, uplink_lost_time, uplink_nb_msgs, downlink_nb_msgs, downlink_rate, uplink_rate, downlink_ovrn)
static inline void pprz_msg_send_DATALINK_REPORT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_uplink_lost_time, uint16_t *_uplink_nb_msgs, uint16_t *_downlink_nb_msgs, uint16_t *_downlink_rate, uint16_t *_uplink_rate, uint8_t *_downlink_ovrn) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+2+2+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_DATALINK_REPORT, "DATALINK_REPORT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _uplink_lost_time);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _uplink_nb_msgs);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _downlink_nb_msgs);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _downlink_rate);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _uplink_rate);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _downlink_ovrn);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_DL_VALUE(_trans, _dev, index, value) pprz_msg_send_DL_VALUE(&((_trans).trans_tx), &((_dev).device), AC_ID, index, value)
static inline void pprz_msg_send_DL_VALUE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_index, float *_value) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_DL_VALUE, "DL_VALUE");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _index);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _value);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_MARK(_trans, _dev, ac_id, lat, long) pprz_msg_send_MARK(&((_trans).trans_tx), &((_dev).device), AC_ID, ac_id, lat, long)
static inline void pprz_msg_send_MARK(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id, float *_lat, float *_long) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_MARK, "MARK");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ac_id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _lat);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _long);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_SYS_MON(_trans, _dev, periodic_time, periodic_time_min, periodic_time_max, periodic_cycle, periodic_cycle_min, periodic_cycle_max, event_number, cpu_load) pprz_msg_send_SYS_MON(&((_trans).trans_tx), &((_dev).device), AC_ID, periodic_time, periodic_time_min, periodic_time_max, periodic_cycle, periodic_cycle_min, periodic_cycle_max, event_number, cpu_load)
static inline void pprz_msg_send_SYS_MON(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_periodic_time, uint16_t *_periodic_time_min, uint16_t *_periodic_time_max, uint16_t *_periodic_cycle, uint16_t *_periodic_cycle_min, uint16_t *_periodic_cycle_max, uint16_t *_event_number, uint8_t *_cpu_load) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+2+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+2+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+2+2+2+2+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_SYS_MON, "SYS_MON");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _periodic_time);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _periodic_time_min);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _periodic_time_max);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _periodic_cycle);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _periodic_cycle_min);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _periodic_cycle_max);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _event_number);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _cpu_load);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_MOTOR(_trans, _dev, rpm, current) pprz_msg_send_MOTOR(&((_trans).trans_tx), &((_dev).device), AC_ID, rpm, current)
static inline void pprz_msg_send_MOTOR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_rpm, int32_t *_current) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_MOTOR, "MOTOR");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _rpm);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _current);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_WP_MOVED(_trans, _dev, wp_id, utm_east, utm_north, alt, utm_zone) pprz_msg_send_WP_MOVED(&((_trans).trans_tx), &((_dev).device), AC_ID, wp_id, utm_east, utm_north, alt, utm_zone)
static inline void pprz_msg_send_WP_MOVED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_wp_id, float *_utm_east, float *_utm_north, float *_alt, uint8_t *_utm_zone) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+4+4+4+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+4+4+4+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+4+4+4+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_WP_MOVED, "WP_MOVED");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _wp_id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _utm_east);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _utm_north);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _alt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _utm_zone);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_MKK(_trans, _dev, nr, rpm, current, temp) pprz_msg_send_MKK(&((_trans).trans_tx), &((_dev).device), AC_ID, nr, rpm, current, temp)
static inline void pprz_msg_send_MKK(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_nr, uint8_t *_rpm, uint8_t *_current, int8_t *_temp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_MKK, "MKK");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _nr);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _rpm);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _current);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT8, DL_FORMAT_SCALAR, 1, (void *) _temp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ENERGY(_trans, _dev, bat, amp, energy, power) pprz_msg_send_ENERGY(&((_trans).trans_tx), &((_dev).device), AC_ID, bat, amp, energy, power)
static inline void pprz_msg_send_ENERGY(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_bat, float *_amp, uint16_t *_energy, float *_power) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ENERGY, "ENERGY");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bat);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _amp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _energy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _power);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_BARO_BMP85_CALIB(_trans, _dev, a1, a2, a3, a4, a5, a6, b1, b2, mb, mc, md) pprz_msg_send_BARO_BMP85_CALIB(&((_trans).trans_tx), &((_dev).device), AC_ID, a1, a2, a3, a4, a5, a6, b1, b2, mb, mc, md)
static inline void pprz_msg_send_BARO_BMP85_CALIB(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_a1, int16_t *_a2, int16_t *_a3, uint16_t *_a4, uint16_t *_a5, uint16_t *_a6, int16_t *_b1, int16_t *_b2, int16_t *_mb, int16_t *_mc, int16_t *_md) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+2+2+2+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+2+2+2+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+2+2+2+2+2+2+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_BARO_BMP85_CALIB, "BARO_BMP85_CALIB");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _a1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _a2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _a3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _a4);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _a5);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _a6);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _b1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _b2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _mb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _mc);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _md);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_BARO_BMP85(_trans, _dev, UT, UP, P, T, MSL) pprz_msg_send_BARO_BMP85(&((_trans).trans_tx), &((_dev).device), AC_ID, UT, UP, P, T, MSL)
static inline void pprz_msg_send_BARO_BMP85(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_UT, int32_t *_UP, uint32_t *_P, float *_T, float *_MSL) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_BARO_BMP85, "BARO_BMP85");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _UT);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _UP);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _P);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _T);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _MSL);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_SPEED_LOOP(_trans, _dev, ve_set_point, ve, vn_set_point, vn, north_sp, east_sp) pprz_msg_send_SPEED_LOOP(&((_trans).trans_tx), &((_dev).device), AC_ID, ve_set_point, ve, vn_set_point, vn, north_sp, east_sp)
static inline void pprz_msg_send_SPEED_LOOP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_ve_set_point, float *_ve, float *_vn_set_point, float *_vn, float *_north_sp, float *_east_sp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_SPEED_LOOP, "SPEED_LOOP");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ve_set_point);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ve);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _vn_set_point);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _vn);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _north_sp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _east_sp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ALT_KALMAN(_trans, _dev, p00, p01, p10, p11) pprz_msg_send_ALT_KALMAN(&((_trans).trans_tx), &((_dev).device), AC_ID, p00, p01, p10, p11)
static inline void pprz_msg_send_ALT_KALMAN(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_p00, float *_p01, float *_p10, float *_p11) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ALT_KALMAN, "ALT_KALMAN");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _p00);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _p01);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _p10);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _p11);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ESTIMATOR(_trans, _dev, z, z_dot) pprz_msg_send_ESTIMATOR(&((_trans).trans_tx), &((_dev).device), AC_ID, z, z_dot)
static inline void pprz_msg_send_ESTIMATOR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_z, float *_z_dot) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ESTIMATOR, "ESTIMATOR");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _z);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _z_dot);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TUNE_ROLL(_trans, _dev, p, phi, phi_sp) pprz_msg_send_TUNE_ROLL(&((_trans).trans_tx), &((_dev).device), AC_ID, p, phi, phi_sp)
static inline void pprz_msg_send_TUNE_ROLL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_p, float *_phi, float *_phi_sp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TUNE_ROLL, "TUNE_ROLL");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _phi_sp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_BARO_MS5534A(_trans, _dev, pressure, temp, alt) pprz_msg_send_BARO_MS5534A(&((_trans).trans_tx), &((_dev).device), AC_ID, pressure, temp, alt)
static inline void pprz_msg_send_BARO_MS5534A(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_pressure, uint16_t *_temp, float *_alt) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_BARO_MS5534A, "BARO_MS5534A");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _pressure);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _temp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _alt);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_PRESSURE(_trans, _dev, airspeed_adc, airspeed, altitude_adc, altitude) pprz_msg_send_PRESSURE(&((_trans).trans_tx), &((_dev).device), AC_ID, airspeed_adc, airspeed, altitude_adc, altitude)
static inline void pprz_msg_send_PRESSURE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_airspeed_adc, float *_airspeed, float *_altitude_adc, float *_altitude) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_PRESSURE, "PRESSURE");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _airspeed_adc);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _airspeed);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _altitude_adc);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _altitude);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_BARO_WORDS(_trans, _dev, w1, w2, w3, w4) pprz_msg_send_BARO_WORDS(&((_trans).trans_tx), &((_dev).device), AC_ID, w1, w2, w3, w4)
static inline void pprz_msg_send_BARO_WORDS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_w1, uint16_t *_w2, uint16_t *_w3, uint16_t *_w4) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_BARO_WORDS, "BARO_WORDS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _w1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _w2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _w3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _w4);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_WP_MOVED_LLA(_trans, _dev, wp_id, lat, lon, alt) pprz_msg_send_WP_MOVED_LLA(&((_trans).trans_tx), &((_dev).device), AC_ID, wp_id, lat, lon, alt)
static inline void pprz_msg_send_WP_MOVED_LLA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_wp_id, int32_t *_lat, int32_t *_lon, int32_t *_alt) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_WP_MOVED_LLA, "WP_MOVED_LLA");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _wp_id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lat);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lon);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _alt);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_CHRONO(_trans, _dev, tag, time) pprz_msg_send_CHRONO(&((_trans).trans_tx), &((_dev).device), AC_ID, tag, time)
static inline void pprz_msg_send_CHRONO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_tag, uint32_t *_time) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_CHRONO, "CHRONO");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _tag);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _time);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_WP_MOVED_ENU(_trans, _dev, wp_id, east, north, up) pprz_msg_send_WP_MOVED_ENU(&((_trans).trans_tx), &((_dev).device), AC_ID, wp_id, east, north, up)
static inline void pprz_msg_send_WP_MOVED_ENU(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_wp_id, int32_t *_east, int32_t *_north, int32_t *_up) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_WP_MOVED_ENU, "WP_MOVED_ENU");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _wp_id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _east);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _north);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _up);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_WINDTURBINE_STATUS_(_trans, _dev, ac_id, tb_id, sync_itow, cycle_time) pprz_msg_send_WINDTURBINE_STATUS_(&((_trans).trans_tx), &((_dev).device), AC_ID, ac_id, tb_id, sync_itow, cycle_time)
static inline void pprz_msg_send_WINDTURBINE_STATUS_(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id, uint8_t *_tb_id, uint32_t *_sync_itow, uint32_t *_cycle_time) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_WINDTURBINE_STATUS_, "WINDTURBINE_STATUS_");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ac_id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _tb_id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _sync_itow);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _cycle_time);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_RC_3CH_(_trans, _dev, throttle_mode, roll, pitch) pprz_msg_send_RC_3CH_(&((_trans).trans_tx), &((_dev).device), AC_ID, throttle_mode, roll, pitch)
static inline void pprz_msg_send_RC_3CH_(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_throttle_mode, int8_t *_roll, int8_t *_pitch) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_RC_3CH_, "RC_3CH_");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _throttle_mode);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT8, DL_FORMAT_SCALAR, 1, (void *) _roll);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT8, DL_FORMAT_SCALAR, 1, (void *) _pitch);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_MPPT(_trans, _dev, nb_values, values) pprz_msg_send_MPPT(&((_trans).trans_tx), &((_dev).device), AC_ID, nb_values, values)
static inline void pprz_msg_send_MPPT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_values, int16_t *_values) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_values*2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_values*2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+nb_values*2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_MPPT, "MPPT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_values);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_ARRAY, 2 * nb_values, (void *) _values);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_DEBUG_IR_I2C(_trans, _dev, ir1, ir2, top) pprz_msg_send_DEBUG_IR_I2C(&((_trans).trans_tx), &((_dev).device), AC_ID, ir1, ir2, top)
static inline void pprz_msg_send_DEBUG_IR_I2C(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_ir1, int16_t *_ir2, int16_t *_top) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_DEBUG_IR_I2C, "DEBUG_IR_I2C");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _ir1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _ir2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _top);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AIRSPEED(_trans, _dev, airspeed, airspeed_sp, airspeed_cnt, groundspeed_sp) pprz_msg_send_AIRSPEED(&((_trans).trans_tx), &((_dev).device), AC_ID, airspeed, airspeed_sp, airspeed_cnt, groundspeed_sp)
static inline void pprz_msg_send_AIRSPEED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_airspeed, float *_airspeed_sp, float *_airspeed_cnt, float *_groundspeed_sp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AIRSPEED, "AIRSPEED");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _airspeed);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _airspeed_sp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _airspeed_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _groundspeed_sp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_XSENS(_trans, _dev, counter, p, q, r, phi, theta, psi, ax, ay, az, vx, vy, vz, lat, lon, alt, status, hour, min, sec, nanosec, year, month, day) pprz_msg_send_XSENS(&((_trans).trans_tx), &((_dev).device), AC_ID, counter, p, q, r, phi, theta, psi, ax, ay, az, vx, vy, vz, lat, lon, alt, status, hour, min, sec, nanosec, year, month, day)
static inline void pprz_msg_send_XSENS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_counter, float *_p, float *_q, float *_r, float *_phi, float *_theta, float *_psi, float *_ax, float *_ay, float *_az, float *_vx, float *_vy, float *_vz, float *_lat, float *_lon, float *_alt, uint8_t *_status, uint8_t *_hour, uint8_t *_min, uint8_t *_sec, uint32_t *_nanosec, uint16_t *_year, uint8_t *_month, uint8_t *_day) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+1+1+1+1+4+2+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+1+1+1+1+4+2+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+1+1+1+1+4+2+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_XSENS, "XSENS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _counter);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ax);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ay);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _az);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _vx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _vy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _vz);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _lat);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _lon);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _alt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _status);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _hour);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _min);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _sec);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _nanosec);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _year);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _month);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _day);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_BARO_ETS(_trans, _dev, adc, offset, scaled) pprz_msg_send_BARO_ETS(&((_trans).trans_tx), &((_dev).device), AC_ID, adc, offset, scaled)
static inline void pprz_msg_send_BARO_ETS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_adc, uint16_t *_offset, float *_scaled) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_BARO_ETS, "BARO_ETS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _adc);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _offset);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _scaled);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AIRSPEED_ETS(_trans, _dev, adc, offset, scaled) pprz_msg_send_AIRSPEED_ETS(&((_trans).trans_tx), &((_dev).device), AC_ID, adc, offset, scaled)
static inline void pprz_msg_send_AIRSPEED_ETS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_adc, uint16_t *_offset, float *_scaled) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AIRSPEED_ETS, "AIRSPEED_ETS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _adc);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _offset);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _scaled);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_PBN(_trans, _dev, airspeed_adc, altitude_adc, airspeed, altitude, airspeed_offset, altitude_offset) pprz_msg_send_PBN(&((_trans).trans_tx), &((_dev).device), AC_ID, airspeed_adc, altitude_adc, airspeed, altitude, airspeed_offset, altitude_offset)
static inline void pprz_msg_send_PBN(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_airspeed_adc, uint16_t *_altitude_adc, float *_airspeed, float *_altitude, uint16_t *_airspeed_offset, uint16_t *_altitude_offset) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4+4+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4+4+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+4+4+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_PBN, "PBN");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _airspeed_adc);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _altitude_adc);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _airspeed);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _altitude);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _airspeed_offset);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _altitude_offset);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_GPS_LLA(_trans, _dev, lat, lon, alt, hmsl, course, speed, climb, week, itow, mode, gps_nb_err) pprz_msg_send_GPS_LLA(&((_trans).trans_tx), &((_dev).device), AC_ID, lat, lon, alt, hmsl, course, speed, climb, week, itow, mode, gps_nb_err)
static inline void pprz_msg_send_GPS_LLA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_lat, int32_t *_lon, int32_t *_alt, int32_t *_hmsl, int16_t *_course, uint16_t *_speed, int16_t *_climb, uint16_t *_week, uint32_t *_itow, uint8_t *_mode, uint8_t *_gps_nb_err) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+2+2+2+2+4+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+2+2+2+2+4+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+2+2+2+2+4+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_GPS_LLA, "GPS_LLA");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lat);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lon);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _alt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _hmsl);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _course);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _speed);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _climb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _week);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _itow);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _mode);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _gps_nb_err);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_H_CTL_A(_trans, _dev, roll_sum_err, roll_sp, roll_ref, phi, aileron_sp, pitch_sum_err, pitch_sp, pitch_ref, theta, elevator_sp) pprz_msg_send_H_CTL_A(&((_trans).trans_tx), &((_dev).device), AC_ID, roll_sum_err, roll_sp, roll_ref, phi, aileron_sp, pitch_sum_err, pitch_sp, pitch_ref, theta, elevator_sp)
static inline void pprz_msg_send_H_CTL_A(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_roll_sum_err, float *_roll_sp, float *_roll_ref, float *_phi, int16_t *_aileron_sp, float *_pitch_sum_err, float *_pitch_sp, float *_pitch_ref, float *_theta, int16_t *_elevator_sp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+2+4+4+4+4+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+2+4+4+4+4+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+2+4+4+4+4+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_H_CTL_A, "H_CTL_A");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _roll_sum_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _roll_sp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _roll_ref);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _aileron_sp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pitch_sum_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pitch_sp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pitch_ref);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _elevator_sp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TURB_PRESSURE_RAW(_trans, _dev, ch_0, ch_1, ch_2, ch_3, ch_4, ch_5, ch_6, ch_7, ch_8, ch_9, ch_10, ch_11, ch_12, ch_13, ch_14, ch_15) pprz_msg_send_TURB_PRESSURE_RAW(&((_trans).trans_tx), &((_dev).device), AC_ID, ch_0, ch_1, ch_2, ch_3, ch_4, ch_5, ch_6, ch_7, ch_8, ch_9, ch_10, ch_11, ch_12, ch_13, ch_14, ch_15)
static inline void pprz_msg_send_TURB_PRESSURE_RAW(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_ch_0, int32_t *_ch_1, int32_t *_ch_2, int32_t *_ch_3, int32_t *_ch_4, int32_t *_ch_5, int32_t *_ch_6, int32_t *_ch_7, int32_t *_ch_8, int32_t *_ch_9, int32_t *_ch_10, int32_t *_ch_11, int32_t *_ch_12, int32_t *_ch_13, int32_t *_ch_14, int32_t *_ch_15) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TURB_PRESSURE_RAW, "TURB_PRESSURE_RAW");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_4);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_5);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_6);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_7);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_8);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_9);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_10);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_11);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_12);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_13);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_14);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ch_15);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TURB_PRESSURE_VOLTAGE(_trans, _dev, ch_1_p, ch_1_t, ch_2_p, ch_2_t, ch_3_p, ch_3_t, ch_4_p, ch_4_t, ch_5_p, ch_5_t, ch_6_p, ch_6_t, ch_7_p, ch_7_t, gnd1, gnd2) pprz_msg_send_TURB_PRESSURE_VOLTAGE(&((_trans).trans_tx), &((_dev).device), AC_ID, ch_1_p, ch_1_t, ch_2_p, ch_2_t, ch_3_p, ch_3_t, ch_4_p, ch_4_t, ch_5_p, ch_5_t, ch_6_p, ch_6_t, ch_7_p, ch_7_t, gnd1, gnd2)
static inline void pprz_msg_send_TURB_PRESSURE_VOLTAGE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_ch_1_p, float *_ch_1_t, float *_ch_2_p, float *_ch_2_t, float *_ch_3_p, float *_ch_3_t, float *_ch_4_p, float *_ch_4_t, float *_ch_5_p, float *_ch_5_t, float *_ch_6_p, float *_ch_6_t, float *_ch_7_p, float *_ch_7_t, float *_gnd1, float *_gnd2) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TURB_PRESSURE_VOLTAGE, "TURB_PRESSURE_VOLTAGE");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ch_1_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ch_1_t);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ch_2_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ch_2_t);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ch_3_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ch_3_t);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ch_4_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ch_4_t);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ch_5_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ch_5_t);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ch_6_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ch_6_t);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ch_7_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ch_7_t);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _gnd1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _gnd2);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_CAM_POINT(_trans, _dev, cam_point_distance_from_home, cam_point_lat, cam_point_lon) pprz_msg_send_CAM_POINT(&((_trans).trans_tx), &((_dev).device), AC_ID, cam_point_distance_from_home, cam_point_lat, cam_point_lon)
static inline void pprz_msg_send_CAM_POINT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_cam_point_distance_from_home, float *_cam_point_lat, float *_cam_point_lon) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_CAM_POINT, "CAM_POINT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _cam_point_distance_from_home);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _cam_point_lat);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _cam_point_lon);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_DC_INFO(_trans, _dev, mode, lat, lon, alt, course, photo_nr, dist, next_dist, start_x, start_y, start_angle, angle, last_block, count, shutter) pprz_msg_send_DC_INFO(&((_trans).trans_tx), &((_dev).device), AC_ID, mode, lat, lon, alt, course, photo_nr, dist, next_dist, start_x, start_y, start_angle, angle, last_block, count, shutter)
static inline void pprz_msg_send_DC_INFO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_mode, int32_t *_lat, int32_t *_lon, int32_t *_alt, float *_course, uint16_t *_photo_nr, float *_dist, float *_next_dist, float *_start_x, float *_start_y, float *_start_angle, float *_angle, float *_last_block, uint16_t *_count, uint8_t *_shutter) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4+2+4+4+4+4+4+4+4+2+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4+2+4+4+4+4+4+4+4+2+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4+4+4+4+2+4+4+4+4+4+4+4+2+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_DC_INFO, "DC_INFO");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _mode);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lat);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lon);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _alt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _course);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _photo_nr);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _dist);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _next_dist);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _start_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _start_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _start_angle);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _angle);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _last_block);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _count);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _shutter);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AMSYS_BARO(_trans, _dev, pBaroRaw, pBaro, pHomePressure, AltOffset, aktuell, Over_Ground, tempBaro) pprz_msg_send_AMSYS_BARO(&((_trans).trans_tx), &((_dev).device), AC_ID, pBaroRaw, pBaro, pHomePressure, AltOffset, aktuell, Over_Ground, tempBaro)
static inline void pprz_msg_send_AMSYS_BARO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_pBaroRaw, float *_pBaro, float *_pHomePressure, float *_AltOffset, float *_aktuell, float *_Over_Ground, float *_tempBaro) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AMSYS_BARO, "AMSYS_BARO");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _pBaroRaw);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pBaro);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pHomePressure);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _AltOffset);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _aktuell);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Over_Ground);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _tempBaro);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AMSYS_AIRSPEED(_trans, _dev, asRaw, asPresure, asAirspeed, asAirsFilt, asTemp) pprz_msg_send_AMSYS_AIRSPEED(&((_trans).trans_tx), &((_dev).device), AC_ID, asRaw, asPresure, asAirspeed, asAirsFilt, asTemp)
static inline void pprz_msg_send_AMSYS_AIRSPEED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_asRaw, float *_asPresure, float *_asAirspeed, float *_asAirsFilt, float *_asTemp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AMSYS_AIRSPEED, "AMSYS_AIRSPEED");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _asRaw);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _asPresure);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _asAirspeed);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _asAirsFilt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _asTemp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_FLIGHT_BENCHMARK(_trans, _dev, SE_As, SE_Alt, SE_Pos, Err_As, Err_Alt, Err_Pos) pprz_msg_send_FLIGHT_BENCHMARK(&((_trans).trans_tx), &((_dev).device), AC_ID, SE_As, SE_Alt, SE_Pos, Err_As, Err_Alt, Err_Pos)
static inline void pprz_msg_send_FLIGHT_BENCHMARK(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_SE_As, float *_SE_Alt, float *_SE_Pos, float *_Err_As, float *_Err_Alt, float *_Err_Pos) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_FLIGHT_BENCHMARK, "FLIGHT_BENCHMARK");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _SE_As);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _SE_Alt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _SE_Pos);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Err_As);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Err_Alt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Err_Pos);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_MPL3115_BARO(_trans, _dev, pressure, temp, alt) pprz_msg_send_MPL3115_BARO(&((_trans).trans_tx), &((_dev).device), AC_ID, pressure, temp, alt)
static inline void pprz_msg_send_MPL3115_BARO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_pressure, int16_t *_temp, float *_alt) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_MPL3115_BARO, "MPL3115_BARO");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _pressure);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _temp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _alt);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AOA(_trans, _dev, raw, angle) pprz_msg_send_AOA(&((_trans).trans_tx), &((_dev).device), AC_ID, raw, angle)
static inline void pprz_msg_send_AOA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_raw, float *_angle) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AOA, "AOA");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _raw);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _angle);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_XTEND_RSSI(_trans, _dev, datalink_time, rssi_fade_margin, duty) pprz_msg_send_XTEND_RSSI(&((_trans).trans_tx), &((_dev).device), AC_ID, datalink_time, rssi_fade_margin, duty)
static inline void pprz_msg_send_XTEND_RSSI(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_datalink_time, uint8_t *_rssi_fade_margin, uint8_t *_duty) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_XTEND_RSSI, "XTEND_RSSI");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _datalink_time);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _rssi_fade_margin);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _duty);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_SUPERBITRF(_trans, _dev, status, cyrf_status, irq_count, rx_packet_count, tx_packet_count, transfer_timeouts, resync_count, uplink_count, rc_count, timing1, timing2, bind_mfg_id, nb_mfg_id, mfg_id) pprz_msg_send_SUPERBITRF(&((_trans).trans_tx), &((_dev).device), AC_ID, status, cyrf_status, irq_count, rx_packet_count, tx_packet_count, transfer_timeouts, resync_count, uplink_count, rc_count, timing1, timing2, bind_mfg_id, nb_mfg_id, mfg_id)
static inline void pprz_msg_send_SUPERBITRF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_status, uint8_t *_cyrf_status, uint32_t *_irq_count, uint32_t *_rx_packet_count, uint32_t *_tx_packet_count, uint32_t *_transfer_timeouts, uint32_t *_resync_count, uint32_t *_uplink_count, uint32_t *_rc_count, uint32_t *_timing1, uint32_t *_timing2, uint32_t *_bind_mfg_id, uint8_t nb_mfg_id, uint8_t *_mfg_id) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+4+4+4+4+4+4+4+4+4+4+1+nb_mfg_id*1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+4+4+4+4+4+4+4+4+4+4+1+nb_mfg_id*1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+4+4+4+4+4+4+4+4+4+4+1+nb_mfg_id*1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_SUPERBITRF, "SUPERBITRF");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _status);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _cyrf_status);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _irq_count);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _rx_packet_count);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _tx_packet_count);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _transfer_timeouts);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _resync_count);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _uplink_count);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _rc_count);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _timing1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _timing2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _bind_mfg_id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_mfg_id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_ARRAY, 1 * nb_mfg_id, (void *) _mfg_id);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_GX3_INFO(_trans, _dev, GX3_freq, chksm_error, hdr_error, GX3_chksm) pprz_msg_send_GX3_INFO(&((_trans).trans_tx), &((_dev).device), AC_ID, GX3_freq, chksm_error, hdr_error, GX3_chksm)
static inline void pprz_msg_send_GX3_INFO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_GX3_freq, uint32_t *_chksm_error, uint32_t *_hdr_error, uint16_t *_GX3_chksm) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_GX3_INFO, "GX3_INFO");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _GX3_freq);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _chksm_error);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _hdr_error);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _GX3_chksm);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_EXPLAIN(_trans, _dev, type, id, nb_string, string) pprz_msg_send_EXPLAIN(&((_trans).trans_tx), &((_dev).device), AC_ID, type, id, nb_string, string)
static inline void pprz_msg_send_EXPLAIN(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_type, uint8_t *_id, uint8_t nb_string, uint8_t *_string) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1+nb_string*1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1+nb_string*1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+1+nb_string*1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_EXPLAIN, "EXPLAIN");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _type);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_string);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_ARRAY, 1 * nb_string, (void *) _string);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_VIDEO_TELEMETRY(_trans, _dev, blob_x1, blob_y1, blob_x2, blob_y2, blob_x3, blob_y3, blob_x4, blob_y4) pprz_msg_send_VIDEO_TELEMETRY(&((_trans).trans_tx), &((_dev).device), AC_ID, blob_x1, blob_y1, blob_x2, blob_y2, blob_x3, blob_y3, blob_x4, blob_y4)
static inline void pprz_msg_send_VIDEO_TELEMETRY(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_blob_x1, int32_t *_blob_y1, int32_t *_blob_x2, int32_t *_blob_y2, int32_t *_blob_x3, int32_t *_blob_y3, int32_t *_blob_x4, int32_t *_blob_y4) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_VIDEO_TELEMETRY, "VIDEO_TELEMETRY");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _blob_x1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _blob_y1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _blob_x2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _blob_y2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _blob_x3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _blob_y3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _blob_x4);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _blob_y4);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_VF_UPDATE(_trans, _dev, baro, range_meter) pprz_msg_send_VF_UPDATE(&((_trans).trans_tx), &((_dev).device), AC_ID, baro, range_meter)
static inline void pprz_msg_send_VF_UPDATE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_baro, float *_range_meter) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_VF_UPDATE, "VF_UPDATE");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _baro);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _range_meter);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_VF_PREDICT(_trans, _dev, accel) pprz_msg_send_VF_PREDICT(&((_trans).trans_tx), &((_dev).device), AC_ID, accel)
static inline void pprz_msg_send_VF_PREDICT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_accel) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_VF_PREDICT, "VF_PREDICT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _accel);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_INV_FILTER(_trans, _dev, quat, phi_inv, theta_inv, psi_inv, Vx_inv, Vy_inv, Vz_inv, Px_inv, Py_inv, Pz_inv, bias_phi, bias_theta, bias_psi, bias_as, bias_hb, meas_baro, meas_gps) pprz_msg_send_INV_FILTER(&((_trans).trans_tx), &((_dev).device), AC_ID, quat, phi_inv, theta_inv, psi_inv, Vx_inv, Vy_inv, Vz_inv, Px_inv, Py_inv, Pz_inv, bias_phi, bias_theta, bias_psi, bias_as, bias_hb, meas_baro, meas_gps)
static inline void pprz_msg_send_INV_FILTER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_quat, float *_phi_inv, float *_theta_inv, float *_psi_inv, float *_Vx_inv, float *_Vy_inv, float *_Vz_inv, float *_Px_inv, float *_Py_inv, float *_Pz_inv, float *_bias_phi, float *_bias_theta, float *_bias_psi, float *_bias_as, float *_bias_hb, float *_meas_baro, float *_meas_gps) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_INV_FILTER, "INV_FILTER");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _quat);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _phi_inv);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _theta_inv);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _psi_inv);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Vx_inv);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Vy_inv);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Vz_inv);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Px_inv);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Py_inv);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Pz_inv);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bias_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bias_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bias_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bias_as);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bias_hb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _meas_baro);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _meas_gps);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_MISSION_STATUS(_trans, _dev, remaining_time, nb_task_list, task_list) pprz_msg_send_MISSION_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, remaining_time, nb_task_list, task_list)
static inline void pprz_msg_send_MISSION_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_remaining_time, uint8_t nb_task_list, uint8_t *_task_list) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+1+nb_task_list*1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+1+nb_task_list*1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+1+nb_task_list*1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_MISSION_STATUS, "MISSION_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _remaining_time);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_task_list);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_ARRAY, 1 * nb_task_list, (void *) _task_list);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_CROSS_TRACK_ERROR(_trans, _dev, cross_track_error, cte_int) pprz_msg_send_CROSS_TRACK_ERROR(&((_trans).trans_tx), &((_dev).device), AC_ID, cross_track_error, cte_int)
static inline void pprz_msg_send_CROSS_TRACK_ERROR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_cross_track_error, float *_cte_int) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_CROSS_TRACK_ERROR, "CROSS_TRACK_ERROR");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _cross_track_error);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _cte_int);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_GENERIC_COM(_trans, _dev, lat, lon, alt, gspeed, course, airspeed, vsupply, energy, throttle, ap_mode, nav_block, flight_time) pprz_msg_send_GENERIC_COM(&((_trans).trans_tx), &((_dev).device), AC_ID, lat, lon, alt, gspeed, course, airspeed, vsupply, energy, throttle, ap_mode, nav_block, flight_time)
static inline void pprz_msg_send_GENERIC_COM(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_lat, int32_t *_lon, int16_t *_alt, uint16_t *_gspeed, int16_t *_course, uint16_t *_airspeed, uint8_t *_vsupply, uint8_t *_energy, uint8_t *_throttle, uint8_t *_ap_mode, uint8_t *_nav_block, uint16_t *_flight_time) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+2+2+2+2+1+1+1+1+1+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+2+2+2+2+1+1+1+1+1+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+2+2+2+2+1+1+1+1+1+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_GENERIC_COM, "GENERIC_COM");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lat);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lon);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _alt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _gspeed);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _course);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _airspeed);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _vsupply);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _energy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _throttle);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ap_mode);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _nav_block);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _flight_time);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_FORMATION_SLOT_TM(_trans, _dev, ac_id, mode, slot_east, slot_north, slot_alt) pprz_msg_send_FORMATION_SLOT_TM(&((_trans).trans_tx), &((_dev).device), AC_ID, ac_id, mode, slot_east, slot_north, slot_alt)
static inline void pprz_msg_send_FORMATION_SLOT_TM(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id, uint8_t *_mode, float *_slot_east, float *_slot_north, float *_slot_alt) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_FORMATION_SLOT_TM, "FORMATION_SLOT_TM");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ac_id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _mode);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _slot_east);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _slot_north);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _slot_alt);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_FORMATION_STATUS_TM(_trans, _dev, ac_id, leader_id, status) pprz_msg_send_FORMATION_STATUS_TM(&((_trans).trans_tx), &((_dev).device), AC_ID, ac_id, leader_id, status)
static inline void pprz_msg_send_FORMATION_STATUS_TM(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id, uint8_t *_leader_id, uint8_t *_status) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_FORMATION_STATUS_TM, "FORMATION_STATUS_TM");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ac_id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _leader_id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _status);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_BMP_STATUS(_trans, _dev, UP, UT, press, temp) pprz_msg_send_BMP_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, UP, UT, press, temp)
static inline void pprz_msg_send_BMP_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_UP, int32_t *_UT, int32_t *_press, int32_t *_temp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_BMP_STATUS, "BMP_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _UP);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _UT);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _press);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _temp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_MLX_STATUS(_trans, _dev, itemp_case, temp_case, itemp_obj, temp_obj) pprz_msg_send_MLX_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, itemp_case, temp_case, itemp_obj, temp_obj)
static inline void pprz_msg_send_MLX_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_itemp_case, float *_temp_case, uint16_t *_itemp_obj, float *_temp_obj) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_MLX_STATUS, "MLX_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _itemp_case);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _temp_case);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _itemp_obj);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _temp_obj);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TMP_STATUS(_trans, _dev, itemp, temp) pprz_msg_send_TMP_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, itemp, temp)
static inline void pprz_msg_send_TMP_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_itemp, float *_temp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TMP_STATUS, "TMP_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _itemp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _temp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_WIND_INFO_RET(_trans, _dev, east, north, airspeed) pprz_msg_send_WIND_INFO_RET(&((_trans).trans_tx), &((_dev).device), AC_ID, east, north, airspeed)
static inline void pprz_msg_send_WIND_INFO_RET(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_east, float *_north, float *_airspeed) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_WIND_INFO_RET, "WIND_INFO_RET");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _east);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _north);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _airspeed);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_SCP_STATUS(_trans, _dev, press, temp) pprz_msg_send_SCP_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, press, temp)
static inline void pprz_msg_send_SCP_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_press, int16_t *_temp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_SCP_STATUS, "SCP_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _press);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _temp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_SHT_STATUS(_trans, _dev, ihumid, itemp, humid, temp) pprz_msg_send_SHT_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, ihumid, itemp, humid, temp)
static inline void pprz_msg_send_SHT_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_ihumid, uint16_t *_itemp, float *_humid, float *_temp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_SHT_STATUS, "SHT_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _ihumid);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _itemp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _humid);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _temp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ENOSE_STATUS(_trans, _dev, val1, val2, val3, PID, nb_heat, heat) pprz_msg_send_ENOSE_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, val1, val2, val3, PID, nb_heat, heat)
static inline void pprz_msg_send_ENOSE_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_val1, uint16_t *_val2, uint16_t *_val3, uint16_t *_PID, uint8_t nb_heat, uint8_t *_heat) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+1+nb_heat*1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+1+nb_heat*1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+2+1+nb_heat*1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ENOSE_STATUS, "ENOSE_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _val1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _val2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _val3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _PID);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_heat);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_ARRAY, 1 * nb_heat, (void *) _heat);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_DPICCO_STATUS(_trans, _dev, humid, temp, fhumid, ftemp) pprz_msg_send_DPICCO_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, humid, temp, fhumid, ftemp)
static inline void pprz_msg_send_DPICCO_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_humid, uint16_t *_temp, float *_fhumid, float *_ftemp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_DPICCO_STATUS, "DPICCO_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _humid);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _temp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _fhumid);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ftemp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ANTENNA_DEBUG(_trans, _dev, mag_xraw, mag_yraw, mag_xcal, mag_ycal, mag_heading, mag_magnitude, mag_temp, mag_distor, mag_cal_status) pprz_msg_send_ANTENNA_DEBUG(&((_trans).trans_tx), &((_dev).device), AC_ID, mag_xraw, mag_yraw, mag_xcal, mag_ycal, mag_heading, mag_magnitude, mag_temp, mag_distor, mag_cal_status)
static inline void pprz_msg_send_ANTENNA_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_mag_xraw, int32_t *_mag_yraw, float *_mag_xcal, float *_mag_ycal, float *_mag_heading, float *_mag_magnitude, float *_mag_temp, uint8_t *_mag_distor, uint8_t *_mag_cal_status) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ANTENNA_DEBUG, "ANTENNA_DEBUG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _mag_xraw);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _mag_yraw);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mag_xcal);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mag_ycal);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mag_heading);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mag_magnitude);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mag_temp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _mag_distor);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _mag_cal_status);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ANTENNA_STATUS(_trans, _dev, azim_sp, elev_sp, id_sp, mode) pprz_msg_send_ANTENNA_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, azim_sp, elev_sp, id_sp, mode)
static inline void pprz_msg_send_ANTENNA_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_azim_sp, float *_elev_sp, uint8_t *_id_sp, uint8_t *_mode) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ANTENNA_STATUS, "ANTENNA_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _azim_sp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _elev_sp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _id_sp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _mode);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_MOTOR_BENCH_STATUS(_trans, _dev, time_ticks, throttle, rpm, current, thrust, torque, time_s, mode) pprz_msg_send_MOTOR_BENCH_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, time_ticks, throttle, rpm, current, thrust, torque, time_s, mode)
static inline void pprz_msg_send_MOTOR_BENCH_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_time_ticks, float *_throttle, float *_rpm, float *_current, float *_thrust, float *_torque, uint16_t *_time_s, uint8_t *_mode) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+2+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+2+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+2+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_MOTOR_BENCH_STATUS, "MOTOR_BENCH_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _time_ticks);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _throttle);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _rpm);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _current);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _thrust);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _torque);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _time_s);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _mode);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_MOTOR_BENCH_STATIC(_trans, _dev, av_rpm, av_thrust, av_current, throttle) pprz_msg_send_MOTOR_BENCH_STATIC(&((_trans).trans_tx), &((_dev).device), AC_ID, av_rpm, av_thrust, av_current, throttle)
static inline void pprz_msg_send_MOTOR_BENCH_STATIC(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_av_rpm, float *_av_thrust, float *_av_current, uint16_t *_throttle) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_MOTOR_BENCH_STATIC, "MOTOR_BENCH_STATIC");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _av_rpm);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _av_thrust);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _av_current);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _throttle);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_HIH_STATUS(_trans, _dev, humid, fhumid, ftemp) pprz_msg_send_HIH_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, humid, fhumid, ftemp)
static inline void pprz_msg_send_HIH_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_humid, float *_fhumid, float *_ftemp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_HIH_STATUS, "HIH_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _humid);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _fhumid);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ftemp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TEMT_STATUS(_trans, _dev, light, f_light) pprz_msg_send_TEMT_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, light, f_light)
static inline void pprz_msg_send_TEMT_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_light, float *_f_light) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TEMT_STATUS, "TEMT_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _light);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _f_light);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_GP2Y_STATUS(_trans, _dev, idensity, density) pprz_msg_send_GP2Y_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, idensity, density)
static inline void pprz_msg_send_GP2Y_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_idensity, float *_density) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_GP2Y_STATUS, "GP2Y_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _idensity);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _density);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_SHT_I2C_SERIAL(_trans, _dev, serial0, serial1) pprz_msg_send_SHT_I2C_SERIAL(&((_trans).trans_tx), &((_dev).device), AC_ID, serial0, serial1)
static inline void pprz_msg_send_SHT_I2C_SERIAL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_serial0, uint32_t *_serial1) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_SHT_I2C_SERIAL, "SHT_I2C_SERIAL");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _serial0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _serial1);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_PPM(_trans, _dev, ppm_rate, nb_values, values) pprz_msg_send_PPM(&((_trans).trans_tx), &((_dev).device), AC_ID, ppm_rate, nb_values, values)
static inline void pprz_msg_send_PPM(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ppm_rate, uint8_t nb_values, uint16_t *_values) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+nb_values*2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+nb_values*2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+nb_values*2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_PPM, "PPM");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ppm_rate);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_values);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_ARRAY, 2 * nb_values, (void *) _values);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_RC(_trans, _dev, nb_values, values) pprz_msg_send_RC(&((_trans).trans_tx), &((_dev).device), AC_ID, nb_values, values)
static inline void pprz_msg_send_RC(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_values, int16_t *_values) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_values*2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_values*2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+nb_values*2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_RC, "RC");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_values);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_ARRAY, 2 * nb_values, (void *) _values);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_COMMANDS(_trans, _dev, nb_values, values) pprz_msg_send_COMMANDS(&((_trans).trans_tx), &((_dev).device), AC_ID, nb_values, values)
static inline void pprz_msg_send_COMMANDS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_values, int16_t *_values) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_values*2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_values*2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+nb_values*2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_COMMANDS, "COMMANDS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_values);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_ARRAY, 2 * nb_values, (void *) _values);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_FBW_STATUS(_trans, _dev, rc_status, frame_rate, mode, vsupply, current) pprz_msg_send_FBW_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, rc_status, frame_rate, mode, vsupply, current)
static inline void pprz_msg_send_FBW_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_rc_status, uint8_t *_frame_rate, uint8_t *_mode, uint16_t *_vsupply, int32_t *_current) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+1+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_FBW_STATUS, "FBW_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _rc_status);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _frame_rate);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _mode);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _vsupply);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _current);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ADC(_trans, _dev, mcu, nb_values, values) pprz_msg_send_ADC(&((_trans).trans_tx), &((_dev).device), AC_ID, mcu, nb_values, values)
static inline void pprz_msg_send_ADC(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_mcu, uint8_t nb_values, uint16_t *_values) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+nb_values*2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+nb_values*2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+nb_values*2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ADC, "ADC");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _mcu);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_values);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_ARRAY, 2 * nb_values, (void *) _values);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ACTUATORS(_trans, _dev, nb_values, values) pprz_msg_send_ACTUATORS(&((_trans).trans_tx), &((_dev).device), AC_ID, nb_values, values)
static inline void pprz_msg_send_ACTUATORS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_values, int16_t *_values) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_values*2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_values*2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+nb_values*2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ACTUATORS, "ACTUATORS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_values);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_ARRAY, 2 * nb_values, (void *) _values);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_BLUEGIGA(_trans, _dev, data_rate, nb_last_msg, last_msg) pprz_msg_send_BLUEGIGA(&((_trans).trans_tx), &((_dev).device), AC_ID, data_rate, nb_last_msg, last_msg)
static inline void pprz_msg_send_BLUEGIGA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_data_rate, uint8_t nb_last_msg, uint8_t *_last_msg) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+1+nb_last_msg*1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+1+nb_last_msg*1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+1+nb_last_msg*1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_BLUEGIGA, "BLUEGIGA");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _data_rate);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_last_msg);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_ARRAY, 1 * nb_last_msg, (void *) _last_msg);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_MULTIGAZE_METERS(_trans, _dev, nb_multigaze_meters, multigaze_meters) pprz_msg_send_MULTIGAZE_METERS(&((_trans).trans_tx), &((_dev).device), AC_ID, nb_multigaze_meters, multigaze_meters)
static inline void pprz_msg_send_MULTIGAZE_METERS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_multigaze_meters, float *_multigaze_meters) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_multigaze_meters*4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_multigaze_meters*4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+nb_multigaze_meters*4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_MULTIGAZE_METERS, "MULTIGAZE_METERS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_multigaze_meters);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_ARRAY, 4 * nb_multigaze_meters, (void *) _multigaze_meters);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_DC_SHOT(_trans, _dev, photo_nr, lat, lon, alt, hmsl, phi, theta, psi, course, speed, itow) pprz_msg_send_DC_SHOT(&((_trans).trans_tx), &((_dev).device), AC_ID, photo_nr, lat, lon, alt, hmsl, phi, theta, psi, course, speed, itow)
static inline void pprz_msg_send_DC_SHOT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_photo_nr, int32_t *_lat, int32_t *_lon, int32_t *_alt, int32_t *_hmsl, int16_t *_phi, int16_t *_theta, int16_t *_psi, int16_t *_course, uint16_t *_speed, uint32_t *_itow) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4+2+2+2+2+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4+2+2+2+2+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4+4+4+4+2+2+2+2+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_DC_SHOT, "DC_SHOT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _photo_nr);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lat);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lon);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _alt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _hmsl);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _course);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _speed);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _itow);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TEST_BOARD_RESULTS(_trans, _dev, uart, ppm, nb_servo, servo) pprz_msg_send_TEST_BOARD_RESULTS(&((_trans).trans_tx), &((_dev).device), AC_ID, uart, ppm, nb_servo, servo)
static inline void pprz_msg_send_TEST_BOARD_RESULTS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_uart, uint8_t *_ppm, uint8_t nb_servo, uint16_t *_servo) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1+nb_servo*2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1+nb_servo*2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+1+nb_servo*2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TEST_BOARD_RESULTS, "TEST_BOARD_RESULTS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _uart);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ppm);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_servo);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_ARRAY, 2 * nb_servo, (void *) _servo);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_MLX_SERIAL(_trans, _dev, serial0, serial1) pprz_msg_send_MLX_SERIAL(&((_trans).trans_tx), &((_dev).device), AC_ID, serial0, serial1)
static inline void pprz_msg_send_MLX_SERIAL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_serial0, uint32_t *_serial1) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_MLX_SERIAL, "MLX_SERIAL");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _serial0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _serial1);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_PAYLOAD(_trans, _dev, nb_values, values) pprz_msg_send_PAYLOAD(&((_trans).trans_tx), &((_dev).device), AC_ID, nb_values, values)
static inline void pprz_msg_send_PAYLOAD(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_values, uint8_t *_values) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_values*1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_values*1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+nb_values*1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_PAYLOAD, "PAYLOAD");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_values);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_ARRAY, 1 * nb_values, (void *) _values);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_HTM_STATUS(_trans, _dev, ihumid, itemp, humid, temp) pprz_msg_send_HTM_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, ihumid, itemp, humid, temp)
static inline void pprz_msg_send_HTM_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_ihumid, uint16_t *_itemp, float *_humid, float *_temp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_HTM_STATUS, "HTM_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _ihumid);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _itemp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _humid);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _temp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_BARO_MS5611(_trans, _dev, d1, d2, pressure, temp) pprz_msg_send_BARO_MS5611(&((_trans).trans_tx), &((_dev).device), AC_ID, d1, d2, pressure, temp)
static inline void pprz_msg_send_BARO_MS5611(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_d1, uint32_t *_d2, float *_pressure, float *_temp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_BARO_MS5611, "BARO_MS5611");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _d1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _d2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pressure);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _temp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_MS5611_COEFF(_trans, _dev, c0, c1, c2, c3, c4, c5, c6, c7) pprz_msg_send_MS5611_COEFF(&((_trans).trans_tx), &((_dev).device), AC_ID, c0, c1, c2, c3, c4, c5, c6, c7)
static inline void pprz_msg_send_MS5611_COEFF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_c0, uint16_t *_c1, uint16_t *_c2, uint16_t *_c3, uint16_t *_c4, uint16_t *_c5, uint16_t *_c6, uint16_t *_c7) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+2+2+2+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_MS5611_COEFF, "MS5611_COEFF");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _c0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _c1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _c2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _c3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _c4);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _c5);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _c6);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _c7);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ATMOSPHERE_CHARGE(_trans, _dev, t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) pprz_msg_send_ATMOSPHERE_CHARGE(&((_trans).trans_tx), &((_dev).device), AC_ID, t0, t1, t2, t3, t4, t5, t6, t7, t8, t9)
static inline void pprz_msg_send_ATMOSPHERE_CHARGE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_t0, uint16_t *_t1, uint16_t *_t2, uint16_t *_t3, uint16_t *_t4, uint16_t *_t5, uint16_t *_t6, uint16_t *_t7, uint16_t *_t8, uint16_t *_t9) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+2+2+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+2+2+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+2+2+2+2+2+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ATMOSPHERE_CHARGE, "ATMOSPHERE_CHARGE");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _t0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _t1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _t2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _t3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _t4);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _t5);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _t6);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _t7);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _t8);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _t9);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_SOLAR_RADIATION(_trans, _dev, up_t0, dn_t0, up_t1, dn_t1, up_t2, dn_t2, up_t3, dn_t3, up_t4, dn_t4, up_t5, dn_t5, up_t6, dn_t6, up_t7, dn_t7, up_t8, dn_t8, up_t9, dn_t9) pprz_msg_send_SOLAR_RADIATION(&((_trans).trans_tx), &((_dev).device), AC_ID, up_t0, dn_t0, up_t1, dn_t1, up_t2, dn_t2, up_t3, dn_t3, up_t4, dn_t4, up_t5, dn_t5, up_t6, dn_t6, up_t7, dn_t7, up_t8, dn_t8, up_t9, dn_t9)
static inline void pprz_msg_send_SOLAR_RADIATION(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_up_t0, uint16_t *_dn_t0, uint16_t *_up_t1, uint16_t *_dn_t1, uint16_t *_up_t2, uint16_t *_dn_t2, uint16_t *_up_t3, uint16_t *_dn_t3, uint16_t *_up_t4, uint16_t *_dn_t4, uint16_t *_up_t5, uint16_t *_dn_t5, uint16_t *_up_t6, uint16_t *_dn_t6, uint16_t *_up_t7, uint16_t *_dn_t7, uint16_t *_up_t8, uint16_t *_dn_t8, uint16_t *_up_t9, uint16_t *_dn_t9) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_SOLAR_RADIATION, "SOLAR_RADIATION");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _up_t0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _dn_t0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _up_t1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _dn_t1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _up_t2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _dn_t2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _up_t3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _dn_t3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _up_t4);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _dn_t4);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _up_t5);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _dn_t5);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _up_t6);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _dn_t6);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _up_t7);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _dn_t7);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _up_t8);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _dn_t8);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _up_t9);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _dn_t9);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TCAS_TA(_trans, _dev, ac_id) pprz_msg_send_TCAS_TA(&((_trans).trans_tx), &((_dev).device), AC_ID, ac_id)
static inline void pprz_msg_send_TCAS_TA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TCAS_TA, "TCAS_TA");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ac_id);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TCAS_RA(_trans, _dev, ac_id, resolve) pprz_msg_send_TCAS_RA(&((_trans).trans_tx), &((_dev).device), AC_ID, ac_id, resolve)
static inline void pprz_msg_send_TCAS_RA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id, uint8_t *_resolve) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TCAS_RA, "TCAS_RA");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ac_id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _resolve);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TCAS_RESOLVED(_trans, _dev, ac_id) pprz_msg_send_TCAS_RESOLVED(&((_trans).trans_tx), &((_dev).device), AC_ID, ac_id)
static inline void pprz_msg_send_TCAS_RESOLVED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TCAS_RESOLVED, "TCAS_RESOLVED");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ac_id);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TCAS_DEBUG(_trans, _dev, ac_id, tau) pprz_msg_send_TCAS_DEBUG(&((_trans).trans_tx), &((_dev).device), AC_ID, ac_id, tau)
static inline void pprz_msg_send_TCAS_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id, float *_tau) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TCAS_DEBUG, "TCAS_DEBUG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ac_id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _tau);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_POTENTIAL(_trans, _dev, east, north, alt, speed, climb) pprz_msg_send_POTENTIAL(&((_trans).trans_tx), &((_dev).device), AC_ID, east, north, alt, speed, climb)
static inline void pprz_msg_send_POTENTIAL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_east, float *_north, float *_alt, float *_speed, float *_climb) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_POTENTIAL, "POTENTIAL");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _east);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _north);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _alt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _speed);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _climb);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_VERTICAL_ENERGY(_trans, _dev, Epot_err, Ekin_err, Etot_err, Edis_err, throttle, nav_pitch, speed_sp) pprz_msg_send_VERTICAL_ENERGY(&((_trans).trans_tx), &((_dev).device), AC_ID, Epot_err, Ekin_err, Etot_err, Edis_err, throttle, nav_pitch, speed_sp)
static inline void pprz_msg_send_VERTICAL_ENERGY(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_Epot_err, float *_Ekin_err, float *_Etot_err, float *_Edis_err, float *_throttle, float *_nav_pitch, float *_speed_sp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_VERTICAL_ENERGY, "VERTICAL_ENERGY");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Epot_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Ekin_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Etot_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Edis_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _throttle);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _nav_pitch);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _speed_sp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TEMP_TCOUPLE(_trans, _dev, fval0, fval1, fval2, fval3, fref0, fref1, fref2, fref3, val0, val1, val2, val3, ref0, ref1, ref2, ref3) pprz_msg_send_TEMP_TCOUPLE(&((_trans).trans_tx), &((_dev).device), AC_ID, fval0, fval1, fval2, fval3, fref0, fref1, fref2, fref3, val0, val1, val2, val3, ref0, ref1, ref2, ref3)
static inline void pprz_msg_send_TEMP_TCOUPLE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_fval0, float *_fval1, float *_fval2, float *_fval3, float *_fref0, float *_fref1, float *_fref2, float *_fref3, uint16_t *_val0, uint16_t *_val1, uint16_t *_val2, uint16_t *_val3, uint16_t *_ref0, uint16_t *_ref1, uint16_t *_ref2, uint16_t *_ref3) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+2+2+2+2+2+2+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+2+2+2+2+2+2+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+2+2+2+2+2+2+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TEMP_TCOUPLE, "TEMP_TCOUPLE");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _fval0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _fval1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _fval2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _fval3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _fref0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _fref1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _fref2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _fref3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _val0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _val1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _val2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _val3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _ref0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _ref1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _ref2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _ref3);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_SHT_I2C_STATUS(_trans, _dev, ihumid, itemp, humid, temp) pprz_msg_send_SHT_I2C_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, ihumid, itemp, humid, temp)
static inline void pprz_msg_send_SHT_I2C_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_ihumid, uint16_t *_itemp, float *_humid, float *_temp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_SHT_I2C_STATUS, "SHT_I2C_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _ihumid);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _itemp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _humid);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _temp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_CAMERA_SNAPSHOT(_trans, _dev, snapshot_image_number) pprz_msg_send_CAMERA_SNAPSHOT(&((_trans).trans_tx), &((_dev).device), AC_ID, snapshot_image_number)
static inline void pprz_msg_send_CAMERA_SNAPSHOT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_snapshot_image_number) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_CAMERA_SNAPSHOT, "CAMERA_SNAPSHOT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _snapshot_image_number);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TIMESTAMP(_trans, _dev, timestamp) pprz_msg_send_TIMESTAMP(&((_trans).trans_tx), &((_dev).device), AC_ID, timestamp)
static inline void pprz_msg_send_TIMESTAMP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_timestamp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TIMESTAMP, "TIMESTAMP");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _timestamp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_STAB_ATTITUDE_FLOAT(_trans, _dev, est_p, est_q, est_r, est_phi, est_theta, est_psi, ref_phi, ref_theta, ref_psi, sum_err_phi, sum_err_theta, sum_err_psi, delta_a_fb, delta_e_fb, delta_r_fb, delta_a_ff, delta_e_ff, delta_r_ff, delta_a, delta_e, delta_r, est_p_d, est_q_d, est_r_d) pprz_msg_send_STAB_ATTITUDE_FLOAT(&((_trans).trans_tx), &((_dev).device), AC_ID, est_p, est_q, est_r, est_phi, est_theta, est_psi, ref_phi, ref_theta, ref_psi, sum_err_phi, sum_err_theta, sum_err_psi, delta_a_fb, delta_e_fb, delta_r_fb, delta_a_ff, delta_e_ff, delta_r_ff, delta_a, delta_e, delta_r, est_p_d, est_q_d, est_r_d)
static inline void pprz_msg_send_STAB_ATTITUDE_FLOAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_est_p, float *_est_q, float *_est_r, float *_est_phi, float *_est_theta, float *_est_psi, float *_ref_phi, float *_ref_theta, float *_ref_psi, float *_sum_err_phi, float *_sum_err_theta, float *_sum_err_psi, float *_delta_a_fb, float *_delta_e_fb, float *_delta_r_fb, float *_delta_a_ff, float *_delta_e_ff, float *_delta_r_ff, int32_t *_delta_a, int32_t *_delta_e, int32_t *_delta_r, float *_est_p_d, float *_est_q_d, float *_est_r_d) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_STAB_ATTITUDE_FLOAT, "STAB_ATTITUDE_FLOAT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _est_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _est_q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _est_r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _est_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _est_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _est_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ref_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ref_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ref_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _sum_err_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _sum_err_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _sum_err_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _delta_a_fb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _delta_e_fb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _delta_r_fb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _delta_a_ff);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _delta_e_ff);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _delta_r_ff);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _delta_a);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _delta_e);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _delta_r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _est_p_d);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _est_q_d);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _est_r_d);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IMU_GYRO_SCALED(_trans, _dev, gp, gq, gr) pprz_msg_send_IMU_GYRO_SCALED(&((_trans).trans_tx), &((_dev).device), AC_ID, gp, gq, gr)
static inline void pprz_msg_send_IMU_GYRO_SCALED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_gp, int32_t *_gq, int32_t *_gr) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IMU_GYRO_SCALED, "IMU_GYRO_SCALED");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _gp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _gq);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _gr);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IMU_ACCEL_SCALED(_trans, _dev, ax, ay, az) pprz_msg_send_IMU_ACCEL_SCALED(&((_trans).trans_tx), &((_dev).device), AC_ID, ax, ay, az)
static inline void pprz_msg_send_IMU_ACCEL_SCALED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_ax, int32_t *_ay, int32_t *_az) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IMU_ACCEL_SCALED, "IMU_ACCEL_SCALED");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ax);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ay);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _az);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IMU_MAG_SCALED(_trans, _dev, mx, my, mz) pprz_msg_send_IMU_MAG_SCALED(&((_trans).trans_tx), &((_dev).device), AC_ID, mx, my, mz)
static inline void pprz_msg_send_IMU_MAG_SCALED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_mx, int32_t *_my, int32_t *_mz) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IMU_MAG_SCALED, "IMU_MAG_SCALED");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _mx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _my);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _mz);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_FILTER(_trans, _dev, phi, theta, psi, measure_phi, measure_theta, measure_psi, corrected_phi, corrected_theta, corrected_psi, correction_phi, correction_theta, correction_psi, bp, bq, br, comp_id) pprz_msg_send_FILTER(&((_trans).trans_tx), &((_dev).device), AC_ID, phi, theta, psi, measure_phi, measure_theta, measure_psi, corrected_phi, corrected_theta, corrected_psi, correction_phi, correction_theta, correction_psi, bp, bq, br, comp_id)
static inline void pprz_msg_send_FILTER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_phi, int32_t *_theta, int32_t *_psi, int32_t *_measure_phi, int32_t *_measure_theta, int32_t *_measure_psi, int32_t *_corrected_phi, int32_t *_corrected_theta, int32_t *_corrected_psi, int32_t *_correction_phi, int32_t *_correction_theta, int32_t *_correction_psi, int32_t *_bp, int32_t *_bq, int32_t *_br, uint8_t *_comp_id) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_FILTER, "FILTER");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _measure_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _measure_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _measure_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _corrected_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _corrected_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _corrected_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _correction_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _correction_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _correction_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _bp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _bq);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _br);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _comp_id);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_FILTER2(_trans, _dev, px, py, pz, gsx, gsy, gsz) pprz_msg_send_FILTER2(&((_trans).trans_tx), &((_dev).device), AC_ID, px, py, pz, gsx, gsy, gsz)
static inline void pprz_msg_send_FILTER2(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_px, int32_t *_py, int32_t *_pz, int32_t *_gsx, int32_t *_gsy, int32_t *_gsz) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_FILTER2, "FILTER2");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _px);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _py);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _pz);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _gsx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _gsy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _gsz);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_RATE_LOOP(_trans, _dev, sp_p, sp_q, sp_r, sumerr_p, sumerr_q, sumerr_r, fb_p, fb_q, fb_r, delta_t) pprz_msg_send_RATE_LOOP(&((_trans).trans_tx), &((_dev).device), AC_ID, sp_p, sp_q, sp_r, sumerr_p, sumerr_q, sumerr_r, fb_p, fb_q, fb_r, delta_t)
static inline void pprz_msg_send_RATE_LOOP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_sp_p, int32_t *_sp_q, int32_t *_sp_r, int32_t *_sumerr_p, int32_t *_sumerr_q, int32_t *_sumerr_r, int32_t *_fb_p, int32_t *_fb_q, int32_t *_fb_r, int32_t *_delta_t) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_RATE_LOOP, "RATE_LOOP");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sumerr_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sumerr_q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sumerr_r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _fb_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _fb_q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _fb_r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _delta_t);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_FILTER_ALIGNER(_trans, _dev, lp_gp, lp_gq, lp_gr, gp, gq, gr, noise, cnt, status) pprz_msg_send_FILTER_ALIGNER(&((_trans).trans_tx), &((_dev).device), AC_ID, lp_gp, lp_gq, lp_gr, gp, gq, gr, noise, cnt, status)
static inline void pprz_msg_send_FILTER_ALIGNER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_lp_gp, int32_t *_lp_gq, int32_t *_lp_gr, int32_t *_gp, int32_t *_gq, int32_t *_gr, int32_t *_noise, int32_t *_cnt, uint8_t *_status) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_FILTER_ALIGNER, "FILTER_ALIGNER");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lp_gp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lp_gq);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lp_gr);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _gp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _gq);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _gr);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _noise);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _status);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AIRSPEED_MS45XX(_trans, _dev, diffPress, temperature, airspeed) pprz_msg_send_AIRSPEED_MS45XX(&((_trans).trans_tx), &((_dev).device), AC_ID, diffPress, temperature, airspeed)
static inline void pprz_msg_send_AIRSPEED_MS45XX(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_diffPress, int16_t *_temperature, float *_airspeed) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AIRSPEED_MS45XX, "AIRSPEED_MS45XX");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _diffPress);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _temperature);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _airspeed);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_FILTER_COR(_trans, _dev, mphi, mtheta, mpsi, qi, qx, qy, qz) pprz_msg_send_FILTER_COR(&((_trans).trans_tx), &((_dev).device), AC_ID, mphi, mtheta, mpsi, qi, qx, qy, qz)
static inline void pprz_msg_send_FILTER_COR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_mphi, int32_t *_mtheta, int32_t *_mpsi, int32_t *_qi, int32_t *_qx, int32_t *_qy, int32_t *_qz) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_FILTER_COR, "FILTER_COR");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _mphi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _mtheta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _mpsi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _qi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _qx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _qy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _qz);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_STAB_ATTITUDE_INT(_trans, _dev, est_p, est_q, est_r, est_phi, est_theta, est_psi, sp_phi, sp_theta, sp_psi, sum_err_phi, sum_err_theta, sum_err_psi, delta_a_fb, delta_e_fb, delta_r_fb, delta_a_ff, delta_e_ff, delta_r_ff, delta_a, delta_e, delta_r) pprz_msg_send_STAB_ATTITUDE_INT(&((_trans).trans_tx), &((_dev).device), AC_ID, est_p, est_q, est_r, est_phi, est_theta, est_psi, sp_phi, sp_theta, sp_psi, sum_err_phi, sum_err_theta, sum_err_psi, delta_a_fb, delta_e_fb, delta_r_fb, delta_a_ff, delta_e_ff, delta_r_ff, delta_a, delta_e, delta_r)
static inline void pprz_msg_send_STAB_ATTITUDE_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_est_p, int32_t *_est_q, int32_t *_est_r, int32_t *_est_phi, int32_t *_est_theta, int32_t *_est_psi, int32_t *_sp_phi, int32_t *_sp_theta, int32_t *_sp_psi, int32_t *_sum_err_phi, int32_t *_sum_err_theta, int32_t *_sum_err_psi, int32_t *_delta_a_fb, int32_t *_delta_e_fb, int32_t *_delta_r_fb, int32_t *_delta_a_ff, int32_t *_delta_e_ff, int32_t *_delta_r_ff, int32_t *_delta_a, int32_t *_delta_e, int32_t *_delta_r) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_STAB_ATTITUDE_INT, "STAB_ATTITUDE_INT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sum_err_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sum_err_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sum_err_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _delta_a_fb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _delta_e_fb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _delta_r_fb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _delta_a_ff);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _delta_e_ff);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _delta_r_ff);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _delta_a);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _delta_e);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _delta_r);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_STAB_ATTITUDE_REF_INT(_trans, _dev, sp_phi, sp_theta, sp_psi, ref_phi, ref_theta, ref_psi, ref_p, ref_q, ref_r, ref_pd, ref_qd, ref_rd) pprz_msg_send_STAB_ATTITUDE_REF_INT(&((_trans).trans_tx), &((_dev).device), AC_ID, sp_phi, sp_theta, sp_psi, ref_phi, ref_theta, ref_psi, ref_p, ref_q, ref_r, ref_pd, ref_qd, ref_rd)
static inline void pprz_msg_send_STAB_ATTITUDE_REF_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_sp_phi, int32_t *_sp_theta, int32_t *_sp_psi, int32_t *_ref_phi, int32_t *_ref_theta, int32_t *_ref_psi, int32_t *_ref_p, int32_t *_ref_q, int32_t *_ref_r, int32_t *_ref_pd, int32_t *_ref_qd, int32_t *_ref_rd) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_STAB_ATTITUDE_REF_INT, "STAB_ATTITUDE_REF_INT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_pd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_qd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_rd);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_STAB_ATTITUDE_REF_FLOAT(_trans, _dev, sp_phi, sp_theta, sp_psi, ref_phi, ref_theta, ref_psi, ref_p, ref_q, ref_r, ref_pd, ref_qd, ref_rd) pprz_msg_send_STAB_ATTITUDE_REF_FLOAT(&((_trans).trans_tx), &((_dev).device), AC_ID, sp_phi, sp_theta, sp_psi, ref_phi, ref_theta, ref_psi, ref_p, ref_q, ref_r, ref_pd, ref_qd, ref_rd)
static inline void pprz_msg_send_STAB_ATTITUDE_REF_FLOAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_sp_phi, float *_sp_theta, float *_sp_psi, float *_ref_phi, float *_ref_theta, float *_ref_psi, float *_ref_p, float *_ref_q, float *_ref_r, float *_ref_pd, float *_ref_qd, float *_ref_rd) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_STAB_ATTITUDE_REF_FLOAT, "STAB_ATTITUDE_REF_FLOAT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _sp_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _sp_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _sp_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ref_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ref_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ref_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ref_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ref_q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ref_r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ref_pd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ref_qd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ref_rd);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ROTORCRAFT_CMD(_trans, _dev, cmd_roll, cmd_pitch, cmd_yaw, cmd_thrust) pprz_msg_send_ROTORCRAFT_CMD(&((_trans).trans_tx), &((_dev).device), AC_ID, cmd_roll, cmd_pitch, cmd_yaw, cmd_thrust)
static inline void pprz_msg_send_ROTORCRAFT_CMD(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_cmd_roll, int32_t *_cmd_pitch, int32_t *_cmd_yaw, int32_t *_cmd_thrust) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ROTORCRAFT_CMD, "ROTORCRAFT_CMD");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cmd_roll);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cmd_pitch);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cmd_yaw);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cmd_thrust);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_GUIDANCE_H_INT(_trans, _dev, sp_x, sp_y, ref_x, ref_y, est_x, est_y) pprz_msg_send_GUIDANCE_H_INT(&((_trans).trans_tx), &((_dev).device), AC_ID, sp_x, sp_y, ref_x, ref_y, est_x, est_y)
static inline void pprz_msg_send_GUIDANCE_H_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_sp_x, int32_t *_sp_y, int32_t *_ref_x, int32_t *_ref_y, int32_t *_est_x, int32_t *_est_y) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_GUIDANCE_H_INT, "GUIDANCE_H_INT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_y);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_VERT_LOOP(_trans, _dev, z_sp, zd_sp, est_z, est_zd, est_zdd, ref_z, ref_zd, ref_zdd, adp_inv_m, adp_cov, adp_meas, sum_err, ff_cmd, fb_cmd, delta_t) pprz_msg_send_VERT_LOOP(&((_trans).trans_tx), &((_dev).device), AC_ID, z_sp, zd_sp, est_z, est_zd, est_zdd, ref_z, ref_zd, ref_zdd, adp_inv_m, adp_cov, adp_meas, sum_err, ff_cmd, fb_cmd, delta_t)
static inline void pprz_msg_send_VERT_LOOP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_z_sp, int32_t *_zd_sp, int32_t *_est_z, int32_t *_est_zd, int32_t *_est_zdd, int32_t *_ref_z, int32_t *_ref_zd, int32_t *_ref_zdd, int32_t *_adp_inv_m, int32_t *_adp_cov, int32_t *_adp_meas, int32_t *_sum_err, int32_t *_ff_cmd, int32_t *_fb_cmd, int32_t *_delta_t) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_VERT_LOOP, "VERT_LOOP");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _z_sp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _zd_sp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_z);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_zd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_zdd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_z);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_zd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_zdd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _adp_inv_m);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _adp_cov);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _adp_meas);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sum_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ff_cmd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _fb_cmd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _delta_t);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_HOVER_LOOP(_trans, _dev, sp_x, sp_y, est_x, est_y, est_xd, est_yd, est_xdd, est_ydd, err_x, err_y, err_xd, err_yd, err_sum_x, err_sum_y, cmd_x, cmd_y, cmd_heading) pprz_msg_send_HOVER_LOOP(&((_trans).trans_tx), &((_dev).device), AC_ID, sp_x, sp_y, est_x, est_y, est_xd, est_yd, est_xdd, est_ydd, err_x, err_y, err_xd, err_yd, err_sum_x, err_sum_y, cmd_x, cmd_y, cmd_heading)
static inline void pprz_msg_send_HOVER_LOOP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_sp_x, int32_t *_sp_y, int32_t *_est_x, int32_t *_est_y, int32_t *_est_xd, int32_t *_est_yd, int32_t *_est_xdd, int32_t *_est_ydd, int32_t *_err_x, int32_t *_err_y, int32_t *_err_xd, int32_t *_err_yd, int32_t *_err_sum_x, int32_t *_err_sum_y, int32_t *_cmd_x, int32_t *_cmd_y, int32_t *_cmd_heading) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_HOVER_LOOP, "HOVER_LOOP");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_xd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_yd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_xdd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_ydd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _err_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _err_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _err_xd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _err_yd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _err_sum_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _err_sum_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cmd_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cmd_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cmd_heading);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ROTORCRAFT_FP(_trans, _dev, east, north, up, veast, vnorth, vup, phi, theta, psi, carrot_east, carrot_north, carrot_up, carrot_psi, thrust, flight_time) pprz_msg_send_ROTORCRAFT_FP(&((_trans).trans_tx), &((_dev).device), AC_ID, east, north, up, veast, vnorth, vup, phi, theta, psi, carrot_east, carrot_north, carrot_up, carrot_psi, thrust, flight_time)
static inline void pprz_msg_send_ROTORCRAFT_FP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_east, int32_t *_north, int32_t *_up, int32_t *_veast, int32_t *_vnorth, int32_t *_vup, int32_t *_phi, int32_t *_theta, int32_t *_psi, int32_t *_carrot_east, int32_t *_carrot_north, int32_t *_carrot_up, int32_t *_carrot_psi, int32_t *_thrust, uint16_t *_flight_time) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ROTORCRAFT_FP, "ROTORCRAFT_FP");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _east);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _north);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _up);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _veast);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _vnorth);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _vup);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _carrot_east);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _carrot_north);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _carrot_up);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _carrot_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _thrust);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _flight_time);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TEMP_ADC(_trans, _dev, temp1, temp2, temp3) pprz_msg_send_TEMP_ADC(&((_trans).trans_tx), &((_dev).device), AC_ID, temp1, temp2, temp3)
static inline void pprz_msg_send_TEMP_ADC(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_temp1, float *_temp2, float *_temp3) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TEMP_ADC, "TEMP_ADC");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _temp1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _temp2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _temp3);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_GUIDANCE_H_REF_INT(_trans, _dev, sp_x, ref_x, sp_xd, ref_xd, ref_xdd, sp_y, ref_y, sp_yd, ref_yd, ref_ydd) pprz_msg_send_GUIDANCE_H_REF_INT(&((_trans).trans_tx), &((_dev).device), AC_ID, sp_x, ref_x, sp_xd, ref_xd, ref_xdd, sp_y, ref_y, sp_yd, ref_yd, ref_ydd)
static inline void pprz_msg_send_GUIDANCE_H_REF_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_sp_x, int32_t *_ref_x, int32_t *_sp_xd, int32_t *_ref_xd, int32_t *_ref_xdd, int32_t *_sp_y, int32_t *_ref_y, int32_t *_sp_yd, int32_t *_ref_yd, int32_t *_ref_ydd) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_GUIDANCE_H_REF_INT, "GUIDANCE_H_REF_INT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_xd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_xd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_xdd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _sp_yd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_yd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_ydd);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ROTORCRAFT_TUNE_HOVER(_trans, _dev, rc_roll, rc_pitch, rc_yaw, cmd_roll, cmd_pitch, cmd_yaw, cmd_thrust, body_phi, body_theta, body_psi) pprz_msg_send_ROTORCRAFT_TUNE_HOVER(&((_trans).trans_tx), &((_dev).device), AC_ID, rc_roll, rc_pitch, rc_yaw, cmd_roll, cmd_pitch, cmd_yaw, cmd_thrust, body_phi, body_theta, body_psi)
static inline void pprz_msg_send_ROTORCRAFT_TUNE_HOVER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_rc_roll, int16_t *_rc_pitch, int16_t *_rc_yaw, int32_t *_cmd_roll, int32_t *_cmd_pitch, int32_t *_cmd_yaw, int32_t *_cmd_thrust, int32_t *_body_phi, int32_t *_body_theta, int32_t *_body_psi) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ROTORCRAFT_TUNE_HOVER, "ROTORCRAFT_TUNE_HOVER");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _rc_roll);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _rc_pitch);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _rc_yaw);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cmd_roll);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cmd_pitch);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cmd_yaw);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cmd_thrust);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_psi);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_INS_Z(_trans, _dev, baro_z, ins_z, ins_zd, ins_zdd) pprz_msg_send_INS_Z(&((_trans).trans_tx), &((_dev).device), AC_ID, baro_z, ins_z, ins_zd, ins_zdd)
static inline void pprz_msg_send_INS_Z(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_baro_z, int32_t *_ins_z, int32_t *_ins_zd, int32_t *_ins_zdd) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_INS_Z, "INS_Z");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _baro_z);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ins_z);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ins_zd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ins_zdd);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_PCAP01_STATUS(_trans, _dev, ihumid, itemp, humid, temp) pprz_msg_send_PCAP01_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, ihumid, itemp, humid, temp)
static inline void pprz_msg_send_PCAP01_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_ihumid, uint32_t *_itemp, float *_humid, float *_temp) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_PCAP01_STATUS, "PCAP01_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _ihumid);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _itemp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _humid);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _temp);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_GEIGER_COUNTER(_trans, _dev, tube1, tube2, vsupply) pprz_msg_send_GEIGER_COUNTER(&((_trans).trans_tx), &((_dev).device), AC_ID, tube1, tube2, vsupply)
static inline void pprz_msg_send_GEIGER_COUNTER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_tube1, uint32_t *_tube2, uint16_t *_vsupply) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_GEIGER_COUNTER, "GEIGER_COUNTER");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _tube1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _tube2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _vsupply);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_INS_REF(_trans, _dev, ecef_x0, ecef_y0, ecef_z0, lat0, lon0, alt0, hmsl0, baro_qfe) pprz_msg_send_INS_REF(&((_trans).trans_tx), &((_dev).device), AC_ID, ecef_x0, ecef_y0, ecef_z0, lat0, lon0, alt0, hmsl0, baro_qfe)
static inline void pprz_msg_send_INS_REF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_ecef_x0, int32_t *_ecef_y0, int32_t *_ecef_z0, int32_t *_lat0, int32_t *_lon0, int32_t *_alt0, int32_t *_hmsl0, float *_baro_qfe) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_INS_REF, "INS_REF");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ecef_x0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ecef_y0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ecef_z0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lat0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lon0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _alt0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _hmsl0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _baro_qfe);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_GPS_INT(_trans, _dev, ecef_x, ecef_y, ecef_z, lat, lon, alt, hmsl, ecef_xd, ecef_yd, ecef_zd, pacc, sacc, tow, pdop, numsv, fix) pprz_msg_send_GPS_INT(&((_trans).trans_tx), &((_dev).device), AC_ID, ecef_x, ecef_y, ecef_z, lat, lon, alt, hmsl, ecef_xd, ecef_yd, ecef_zd, pacc, sacc, tow, pdop, numsv, fix)
static inline void pprz_msg_send_GPS_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_ecef_x, int32_t *_ecef_y, int32_t *_ecef_z, int32_t *_lat, int32_t *_lon, int32_t *_alt, int32_t *_hmsl, int32_t *_ecef_xd, int32_t *_ecef_yd, int32_t *_ecef_zd, uint32_t *_pacc, uint32_t *_sacc, uint32_t *_tow, uint16_t *_pdop, uint8_t *_numsv, uint8_t *_fix) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+2+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+2+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+2+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_GPS_INT, "GPS_INT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ecef_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ecef_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ecef_z);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lat);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _lon);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _alt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _hmsl);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ecef_xd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ecef_yd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ecef_zd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _pacc);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _sacc);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _tow);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _pdop);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _numsv);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _fix);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AHRS_EULER_INT(_trans, _dev, imu_phi, imu_theta, imu_psi, body_phi, body_theta, body_psi, comp_id) pprz_msg_send_AHRS_EULER_INT(&((_trans).trans_tx), &((_dev).device), AC_ID, imu_phi, imu_theta, imu_psi, body_phi, body_theta, body_psi, comp_id)
static inline void pprz_msg_send_AHRS_EULER_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_imu_phi, int32_t *_imu_theta, int32_t *_imu_psi, int32_t *_body_phi, int32_t *_body_theta, int32_t *_body_psi, uint8_t *_comp_id) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AHRS_EULER_INT, "AHRS_EULER_INT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _comp_id);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AHRS_QUAT_INT(_trans, _dev, weight, imu_qi, imu_qx, imu_qy, imu_qz, body_qi, body_qx, body_qy, body_qz, comp_id) pprz_msg_send_AHRS_QUAT_INT(&((_trans).trans_tx), &((_dev).device), AC_ID, weight, imu_qi, imu_qx, imu_qy, imu_qz, body_qi, body_qx, body_qy, body_qz, comp_id)
static inline void pprz_msg_send_AHRS_QUAT_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_weight, int32_t *_imu_qi, int32_t *_imu_qx, int32_t *_imu_qy, int32_t *_imu_qz, int32_t *_body_qi, int32_t *_body_qx, int32_t *_body_qy, int32_t *_body_qz, uint8_t *_comp_id) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AHRS_QUAT_INT, "AHRS_QUAT_INT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _weight);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_qi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_qx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_qy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_qz);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_qi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_qx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_qy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_qz);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _comp_id);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AHRS_RMAT_INT(_trans, _dev, imu_m00, imu_m01, imu_m02, imu_m10, imu_m11, imu_m12, imu_m20, imu_m21, imu_m22, body_m00, body_m01, body_m02, body_m10, body_m11, body_m12, body_m20, body_m21, body_m22, comp_id) pprz_msg_send_AHRS_RMAT_INT(&((_trans).trans_tx), &((_dev).device), AC_ID, imu_m00, imu_m01, imu_m02, imu_m10, imu_m11, imu_m12, imu_m20, imu_m21, imu_m22, body_m00, body_m01, body_m02, body_m10, body_m11, body_m12, body_m20, body_m21, body_m22, comp_id)
static inline void pprz_msg_send_AHRS_RMAT_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_imu_m00, int32_t *_imu_m01, int32_t *_imu_m02, int32_t *_imu_m10, int32_t *_imu_m11, int32_t *_imu_m12, int32_t *_imu_m20, int32_t *_imu_m21, int32_t *_imu_m22, int32_t *_body_m00, int32_t *_body_m01, int32_t *_body_m02, int32_t *_body_m10, int32_t *_body_m11, int32_t *_body_m12, int32_t *_body_m20, int32_t *_body_m21, int32_t *_body_m22, uint8_t *_comp_id) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AHRS_RMAT_INT, "AHRS_RMAT_INT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_m00);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_m01);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_m02);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_m10);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_m11);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_m12);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_m20);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_m21);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _imu_m22);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_m00);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_m01);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_m02);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_m10);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_m11);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_m12);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_m20);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_m21);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_m22);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _comp_id);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ROTORCRAFT_NAV_STATUS(_trans, _dev, block_time, stage_time, dist_home, dist_wp, cur_block, cur_stage, horizontal_mode) pprz_msg_send_ROTORCRAFT_NAV_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, block_time, stage_time, dist_home, dist_wp, cur_block, cur_stage, horizontal_mode)
static inline void pprz_msg_send_ROTORCRAFT_NAV_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_block_time, uint16_t *_stage_time, float *_dist_home, float *_dist_wp, uint8_t *_cur_block, uint8_t *_cur_stage, uint8_t *_horizontal_mode) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4+4+1+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+4+4+1+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+4+4+1+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ROTORCRAFT_NAV_STATUS, "ROTORCRAFT_NAV_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _block_time);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _stage_time);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _dist_home);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _dist_wp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _cur_block);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _cur_stage);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _horizontal_mode);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ROTORCRAFT_RADIO_CONTROL(_trans, _dev, roll, pitch, yaw, throttle, mode, kill, status) pprz_msg_send_ROTORCRAFT_RADIO_CONTROL(&((_trans).trans_tx), &((_dev).device), AC_ID, roll, pitch, yaw, throttle, mode, kill, status)
static inline void pprz_msg_send_ROTORCRAFT_RADIO_CONTROL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_roll, int16_t *_pitch, int16_t *_yaw, int16_t *_throttle, int16_t *_mode, int16_t *_kill, uint8_t *_status) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+2+2+2+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ROTORCRAFT_RADIO_CONTROL, "ROTORCRAFT_RADIO_CONTROL");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _roll);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _pitch);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _yaw);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _throttle);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _mode);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _kill);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _status);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_VFF_EXTENDED(_trans, _dev, meas_baro, meas_alt, z, zd, zdd, bias, offset) pprz_msg_send_VFF_EXTENDED(&((_trans).trans_tx), &((_dev).device), AC_ID, meas_baro, meas_alt, z, zd, zdd, bias, offset)
static inline void pprz_msg_send_VFF_EXTENDED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_meas_baro, float *_meas_alt, float *_z, float *_zd, float *_zdd, float *_bias, float *_offset) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_VFF_EXTENDED, "VFF_EXTENDED");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _meas_baro);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _meas_alt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _z);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _zd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _zdd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bias);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _offset);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_VFF(_trans, _dev, measure, z, zd, bias, Pzz, Pzdzd, Pbb) pprz_msg_send_VFF(&((_trans).trans_tx), &((_dev).device), AC_ID, measure, z, zd, bias, Pzz, Pzdzd, Pbb)
static inline void pprz_msg_send_VFF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_measure, float *_z, float *_zd, float *_bias, float *_Pzz, float *_Pzdzd, float *_Pbb) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_VFF, "VFF");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _measure);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _z);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _zd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bias);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Pzz);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Pzdzd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Pbb);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_GEO_MAG(_trans, _dev, Hx, Hy, Hz, comp_id) pprz_msg_send_GEO_MAG(&((_trans).trans_tx), &((_dev).device), AC_ID, Hx, Hy, Hz, comp_id)
static inline void pprz_msg_send_GEO_MAG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_Hx, float *_Hy, float *_Hz, uint8_t *_comp_id) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_GEO_MAG, "GEO_MAG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Hx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Hy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Hz);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _comp_id);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_HFF(_trans, _dev, x, y, xd, yd, xdd, ydd) pprz_msg_send_HFF(&((_trans).trans_tx), &((_dev).device), AC_ID, x, y, xd, yd, xdd, ydd)
static inline void pprz_msg_send_HFF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_x, float *_y, float *_xd, float *_yd, float *_xdd, float *_ydd) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_HFF, "HFF");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _xd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _yd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _xdd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ydd);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_HFF_DBG(_trans, _dev, x_measure, y_measure, xd_measure, yd_measure, Pxx, Pyy, Pxdxd, Pydyd) pprz_msg_send_HFF_DBG(&((_trans).trans_tx), &((_dev).device), AC_ID, x_measure, y_measure, xd_measure, yd_measure, Pxx, Pyy, Pxdxd, Pydyd)
static inline void pprz_msg_send_HFF_DBG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_x_measure, float *_y_measure, float *_xd_measure, float *_yd_measure, float *_Pxx, float *_Pyy, float *_Pxdxd, float *_Pydyd) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_HFF_DBG, "HFF_DBG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _x_measure);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _y_measure);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _xd_measure);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _yd_measure);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Pxx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Pyy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Pxdxd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _Pydyd);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_HFF_GPS(_trans, _dev, lag_cnt, lag_cnt_err, save_cnt) pprz_msg_send_HFF_GPS(&((_trans).trans_tx), &((_dev).device), AC_ID, lag_cnt, lag_cnt_err, save_cnt)
static inline void pprz_msg_send_HFF_GPS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_lag_cnt, int16_t *_lag_cnt_err, int16_t *_save_cnt) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_HFF_GPS, "HFF_GPS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _lag_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _lag_cnt_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _save_cnt);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_INS_SONAR(_trans, _dev, distance, var) pprz_msg_send_INS_SONAR(&((_trans).trans_tx), &((_dev).device), AC_ID, distance, var)
static inline void pprz_msg_send_INS_SONAR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_distance, float *_var) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_INS_SONAR, "INS_SONAR");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _distance);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _var);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ROTORCRAFT_CAM(_trans, _dev, tilt, pan) pprz_msg_send_ROTORCRAFT_CAM(&((_trans).trans_tx), &((_dev).device), AC_ID, tilt, pan)
static inline void pprz_msg_send_ROTORCRAFT_CAM(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_tilt, int16_t *_pan) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ROTORCRAFT_CAM, "ROTORCRAFT_CAM");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _tilt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _pan);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AHRS_REF_QUAT(_trans, _dev, ref_qi, ref_qx, ref_qy, ref_qz, body_qi, body_qx, body_qy, body_qz) pprz_msg_send_AHRS_REF_QUAT(&((_trans).trans_tx), &((_dev).device), AC_ID, ref_qi, ref_qx, ref_qy, ref_qz, body_qi, body_qx, body_qy, body_qz)
static inline void pprz_msg_send_AHRS_REF_QUAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_ref_qi, int32_t *_ref_qx, int32_t *_ref_qy, int32_t *_ref_qz, int32_t *_body_qi, int32_t *_body_qx, int32_t *_body_qy, int32_t *_body_qz) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AHRS_REF_QUAT, "AHRS_REF_QUAT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_qi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_qx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_qy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_qz);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_qi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_qx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_qy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _body_qz);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_EKF7_XHAT(_trans, _dev, c, s1, s2, s3, p, q, r, bp, bq, br) pprz_msg_send_EKF7_XHAT(&((_trans).trans_tx), &((_dev).device), AC_ID, c, s1, s2, s3, p, q, r, bp, bq, br)
static inline void pprz_msg_send_EKF7_XHAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_c, float *_s1, float *_s2, float *_s3, float *_p, float *_q, float *_r, float *_bp, float *_bq, float *_br) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_EKF7_XHAT, "EKF7_XHAT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _c);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _s1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _s2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _s3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bq);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _br);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_EKF7_Y(_trans, _dev, timecount, g1, g2, g3, m1, m2, m3, p, q, r) pprz_msg_send_EKF7_Y(&((_trans).trans_tx), &((_dev).device), AC_ID, timecount, g1, g2, g3, m1, m2, m3, p, q, r)
static inline void pprz_msg_send_EKF7_Y(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_timecount, float *_g1, float *_g2, float *_g3, float *_m1, float *_m2, float *_m3, float *_p, float *_q, float *_r) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_EKF7_Y, "EKF7_Y");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _timecount);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _g1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _g2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _g3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _m1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _m2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _m3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _r);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_EKF7_P_DIAG(_trans, _dev, c, s1, s2, s3, p, q, r, bp, bq, br) pprz_msg_send_EKF7_P_DIAG(&((_trans).trans_tx), &((_dev).device), AC_ID, c, s1, s2, s3, p, q, r, bp, bq, br)
static inline void pprz_msg_send_EKF7_P_DIAG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_c, float *_s1, float *_s2, float *_s3, float *_p, float *_q, float *_r, float *_bp, float *_bq, float *_br) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_EKF7_P_DIAG, "EKF7_P_DIAG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _c);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _s1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _s2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _s3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bq);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _br);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AHRS_EULER(_trans, _dev, phi, theta, psi, comp_id) pprz_msg_send_AHRS_EULER(&((_trans).trans_tx), &((_dev).device), AC_ID, phi, theta, psi, comp_id)
static inline void pprz_msg_send_AHRS_EULER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_phi, float *_theta, float *_psi, uint8_t *_comp_id) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AHRS_EULER, "AHRS_EULER");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _comp_id);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AHRS_MEASUREMENT_EULER(_trans, _dev, phi, theta, psi) pprz_msg_send_AHRS_MEASUREMENT_EULER(&((_trans).trans_tx), &((_dev).device), AC_ID, phi, theta, psi)
static inline void pprz_msg_send_AHRS_MEASUREMENT_EULER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_phi, float *_theta, float *_psi) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AHRS_MEASUREMENT_EULER, "AHRS_MEASUREMENT_EULER");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _psi);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_WT(_trans, _dev, rpm) pprz_msg_send_WT(&((_trans).trans_tx), &((_dev).device), AC_ID, rpm)
static inline void pprz_msg_send_WT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_rpm) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_WT, "WT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _rpm);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_CSC_CAN_DEBUG(_trans, _dev, err_nb, err_code) pprz_msg_send_CSC_CAN_DEBUG(&((_trans).trans_tx), &((_dev).device), AC_ID, err_nb, err_code)
static inline void pprz_msg_send_CSC_CAN_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_err_nb, uint32_t *_err_code) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_CSC_CAN_DEBUG, "CSC_CAN_DEBUG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _err_nb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _err_code);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_CSC_CAN_MSG(_trans, _dev, frame, id, data_a, data_b) pprz_msg_send_CSC_CAN_MSG(&((_trans).trans_tx), &((_dev).device), AC_ID, frame, id, data_a, data_b)
static inline void pprz_msg_send_CSC_CAN_MSG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_frame, uint32_t *_id, uint32_t *_data_a, uint32_t *_data_b) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_CSC_CAN_MSG, "CSC_CAN_MSG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _frame);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _data_a);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _data_b);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AHRS_GYRO_BIAS_INT(_trans, _dev, bp, bq, br, comp_id) pprz_msg_send_AHRS_GYRO_BIAS_INT(&((_trans).trans_tx), &((_dev).device), AC_ID, bp, bq, br, comp_id)
static inline void pprz_msg_send_AHRS_GYRO_BIAS_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_bp, int32_t *_bq, int32_t *_br, uint8_t *_comp_id) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AHRS_GYRO_BIAS_INT, "AHRS_GYRO_BIAS_INT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _bp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _bq);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _br);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _comp_id);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_FLOW_AP_OTF(_trans, _dev, counter, velocity, a_attack, a_sidesl, altitude, checksum) pprz_msg_send_FLOW_AP_OTF(&((_trans).trans_tx), &((_dev).device), AC_ID, counter, velocity, a_attack, a_sidesl, altitude, checksum)
static inline void pprz_msg_send_FLOW_AP_OTF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_counter, int16_t *_velocity, int16_t *_a_attack, int16_t *_a_sidesl, int32_t *_altitude, uint8_t *_checksum) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+2+2+2+4+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+2+2+2+4+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+2+2+2+4+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_FLOW_AP_OTF, "FLOW_AP_OTF");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _counter);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _velocity);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _a_attack);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _a_sidesl);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _altitude);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _checksum);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_FMS_TIME(_trans, _dev, tv_sec, tv_nsec, delay_ns) pprz_msg_send_FMS_TIME(&((_trans).trans_tx), &((_dev).device), AC_ID, tv_sec, tv_nsec, delay_ns)
static inline void pprz_msg_send_FMS_TIME(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_tv_sec, uint32_t *_tv_nsec, uint32_t *_delay_ns) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_FMS_TIME, "FMS_TIME");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _tv_sec);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _tv_nsec);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _delay_ns);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_LOADCELL(_trans, _dev, load) pprz_msg_send_LOADCELL(&((_trans).trans_tx), &((_dev).device), AC_ID, load)
static inline void pprz_msg_send_LOADCELL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_load) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_LOADCELL, "LOADCELL");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _load);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_FLA_DEBUG(_trans, _dev, past_input, imu_rate, desired_accel, motor_command) pprz_msg_send_FLA_DEBUG(&((_trans).trans_tx), &((_dev).device), AC_ID, past_input, imu_rate, desired_accel, motor_command)
static inline void pprz_msg_send_FLA_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_past_input, float *_imu_rate, float *_desired_accel, float *_motor_command) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_FLA_DEBUG, "FLA_DEBUG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _past_input);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _imu_rate);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _desired_accel);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _motor_command);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_BLMC_FAULT_STATUS(_trans, _dev, nb_raw_fault, raw_fault) pprz_msg_send_BLMC_FAULT_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, nb_raw_fault, raw_fault)
static inline void pprz_msg_send_BLMC_FAULT_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_raw_fault, uint16_t *_raw_fault) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_raw_fault*2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_raw_fault*2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+nb_raw_fault*2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_BLMC_FAULT_STATUS, "BLMC_FAULT_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_raw_fault);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_ARRAY, 2 * nb_raw_fault, (void *) _raw_fault);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_BLMC_SPEEDS(_trans, _dev, nb_speeds, speeds) pprz_msg_send_BLMC_SPEEDS(&((_trans).trans_tx), &((_dev).device), AC_ID, nb_speeds, speeds)
static inline void pprz_msg_send_BLMC_SPEEDS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_speeds, int16_t *_speeds) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_speeds*2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_speeds*2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+nb_speeds*2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_BLMC_SPEEDS, "BLMC_SPEEDS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_speeds);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_ARRAY, 2 * nb_speeds, (void *) _speeds);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AHRS_DEBUG_QUAT(_trans, _dev, jqi, jqx, jqy, jqz, xqi, xqx, xqy, xqz, mqi, mqx, mqy, mqz) pprz_msg_send_AHRS_DEBUG_QUAT(&((_trans).trans_tx), &((_dev).device), AC_ID, jqi, jqx, jqy, jqz, xqi, xqx, xqy, xqz, mqi, mqx, mqy, mqz)
static inline void pprz_msg_send_AHRS_DEBUG_QUAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_jqi, float *_jqx, float *_jqy, float *_jqz, float *_xqi, float *_xqx, float *_xqy, float *_xqz, float *_mqi, float *_mqx, float *_mqy, float *_mqz) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AHRS_DEBUG_QUAT, "AHRS_DEBUG_QUAT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _jqi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _jqx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _jqy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _jqz);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _xqi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _xqx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _xqy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _xqz);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mqi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mqx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mqy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mqz);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_BLMC_BUSVOLTS(_trans, _dev, nb_busvolts, busvolts) pprz_msg_send_BLMC_BUSVOLTS(&((_trans).trans_tx), &((_dev).device), AC_ID, nb_busvolts, busvolts)
static inline void pprz_msg_send_BLMC_BUSVOLTS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_busvolts, uint16_t *_busvolts) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_busvolts*2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_busvolts*2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+nb_busvolts*2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_BLMC_BUSVOLTS, "BLMC_BUSVOLTS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_busvolts);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_ARRAY, 2 * nb_busvolts, (void *) _busvolts);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_SYSTEM_STATUS(_trans, _dev, csc1_loop_count, csc1_msg_count, csc2_loop_count, csc2_msg_count, can_rx_err, can_tx_err, rc_parser_err, system_fault) pprz_msg_send_SYSTEM_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, csc1_loop_count, csc1_msg_count, csc2_loop_count, csc2_msg_count, can_rx_err, can_tx_err, rc_parser_err, system_fault)
static inline void pprz_msg_send_SYSTEM_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_csc1_loop_count, uint32_t *_csc1_msg_count, uint32_t *_csc2_loop_count, uint32_t *_csc2_msg_count, uint32_t *_can_rx_err, uint32_t *_can_tx_err, uint32_t *_rc_parser_err, uint8_t *_system_fault) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_SYSTEM_STATUS, "SYSTEM_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _csc1_loop_count);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _csc1_msg_count);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _csc2_loop_count);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _csc2_msg_count);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _can_rx_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _can_tx_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _rc_parser_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _system_fault);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_DYNAMIXEL(_trans, _dev, left_wing, right_wing, left_wing_flag, right_wing_flag, invalid_position, timeout_events, checksum_errors, fuse_rotation_angle, fuse_rotation_rate) pprz_msg_send_DYNAMIXEL(&((_trans).trans_tx), &((_dev).device), AC_ID, left_wing, right_wing, left_wing_flag, right_wing_flag, invalid_position, timeout_events, checksum_errors, fuse_rotation_angle, fuse_rotation_rate)
static inline void pprz_msg_send_DYNAMIXEL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_left_wing, uint16_t *_right_wing, uint8_t *_left_wing_flag, uint8_t *_right_wing_flag, uint32_t *_invalid_position, uint32_t *_timeout_events, uint32_t *_checksum_errors, float *_fuse_rotation_angle, float *_fuse_rotation_rate) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+1+1+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+1+1+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+1+1+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_DYNAMIXEL, "DYNAMIXEL");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _left_wing);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _right_wing);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _left_wing_flag);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _right_wing_flag);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _invalid_position);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _timeout_events);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _checksum_errors);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _fuse_rotation_angle);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _fuse_rotation_rate);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_RMAT_DEBUG(_trans, _dev, a, b, c, d, e, f, g, h, i) pprz_msg_send_RMAT_DEBUG(&((_trans).trans_tx), &((_dev).device), AC_ID, a, b, c, d, e, f, g, h, i)
static inline void pprz_msg_send_RMAT_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_a, float *_b, float *_c, float *_d, float *_e, float *_f, float *_g, float *_h, float *_i) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_RMAT_DEBUG, "RMAT_DEBUG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _a);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _b);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _c);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _d);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _e);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _f);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _g);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _h);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _i);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_SIMPLE_COMMANDS(_trans, _dev, roll, pitch, yaw) pprz_msg_send_SIMPLE_COMMANDS(&((_trans).trans_tx), &((_dev).device), AC_ID, roll, pitch, yaw)
static inline void pprz_msg_send_SIMPLE_COMMANDS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_roll, int16_t *_pitch, int16_t *_yaw) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_SIMPLE_COMMANDS, "SIMPLE_COMMANDS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _roll);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _pitch);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _yaw);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_VANE_SENSOR(_trans, _dev, alpha, alpha_filtered, alpha_target, alpha_vane_error, alpha2, beta, beta_filtered, beta_target, beta_vane_error, beta2) pprz_msg_send_VANE_SENSOR(&((_trans).trans_tx), &((_dev).device), AC_ID, alpha, alpha_filtered, alpha_target, alpha_vane_error, alpha2, beta, beta_filtered, beta_target, beta_vane_error, beta2)
static inline void pprz_msg_send_VANE_SENSOR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_alpha, float *_alpha_filtered, float *_alpha_target, float *_alpha_vane_error, float *_alpha2, float *_beta, float *_beta_filtered, float *_beta_target, float *_beta_vane_error, float *_beta2) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_VANE_SENSOR, "VANE_SENSOR");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _alpha);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _alpha_filtered);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _alpha_target);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _alpha_vane_error);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _alpha2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _beta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _beta_filtered);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _beta_target);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _beta_vane_error);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _beta2);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_CONTROLLER_GAINS(_trans, _dev, roll_gamma_p, roll_gamma_d, roll_gamma_i, pitch_gamma_p, pitch_gamma_d, pitch_gamma_i, yaw_gamma_p, yaw_gamma_d, yaw_gamma_i) pprz_msg_send_CONTROLLER_GAINS(&((_trans).trans_tx), &((_dev).device), AC_ID, roll_gamma_p, roll_gamma_d, roll_gamma_i, pitch_gamma_p, pitch_gamma_d, pitch_gamma_i, yaw_gamma_p, yaw_gamma_d, yaw_gamma_i)
static inline void pprz_msg_send_CONTROLLER_GAINS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_roll_gamma_p, float *_roll_gamma_d, float *_roll_gamma_i, float *_pitch_gamma_p, float *_pitch_gamma_d, float *_pitch_gamma_i, float *_yaw_gamma_p, float *_yaw_gamma_d, float *_yaw_gamma_i) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_CONTROLLER_GAINS, "CONTROLLER_GAINS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _roll_gamma_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _roll_gamma_d);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _roll_gamma_i);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pitch_gamma_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pitch_gamma_d);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pitch_gamma_i);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _yaw_gamma_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _yaw_gamma_d);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _yaw_gamma_i);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AHRS_LKF(_trans, _dev, phi, theta, psi, qi, qx, qy, qz, p, q, r, ax, ay, az, mx, my, mz) pprz_msg_send_AHRS_LKF(&((_trans).trans_tx), &((_dev).device), AC_ID, phi, theta, psi, qi, qx, qy, qz, p, q, r, ax, ay, az, mx, my, mz)
static inline void pprz_msg_send_AHRS_LKF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_phi, float *_theta, float *_psi, float *_qi, float *_qx, float *_qy, float *_qz, float *_p, float *_q, float *_r, float *_ax, float *_ay, float *_az, float *_mx, float *_my, float *_mz) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AHRS_LKF, "AHRS_LKF");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _qi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _qx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _qy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _qz);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ax);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ay);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _az);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _my);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mz);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AHRS_LKF_DEBUG(_trans, _dev, phi_err, theta_err, psi_err, bp, bq, br, quat_norm, phi_accel, theta_accel, phi_cov, theta_cov, psi_cov, bp_cov, bq_cov, br_cov) pprz_msg_send_AHRS_LKF_DEBUG(&((_trans).trans_tx), &((_dev).device), AC_ID, phi_err, theta_err, psi_err, bp, bq, br, quat_norm, phi_accel, theta_accel, phi_cov, theta_cov, psi_cov, bp_cov, bq_cov, br_cov)
static inline void pprz_msg_send_AHRS_LKF_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_phi_err, float *_theta_err, float *_psi_err, float *_bp, float *_bq, float *_br, float *_quat_norm, float *_phi_accel, float *_theta_accel, float *_phi_cov, float *_theta_cov, float *_psi_cov, float *_bp_cov, float *_bq_cov, float *_br_cov) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AHRS_LKF_DEBUG, "AHRS_LKF_DEBUG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _phi_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _theta_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _psi_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bq);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _br);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _quat_norm);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _phi_accel);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _theta_accel);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _phi_cov);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _theta_cov);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _psi_cov);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bp_cov);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bq_cov);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _br_cov);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AHRS_LKF_ACC_DBG(_trans, _dev, qi_err, qx_err, qy_err, qz_err, bp_err, bq_err, br_err) pprz_msg_send_AHRS_LKF_ACC_DBG(&((_trans).trans_tx), &((_dev).device), AC_ID, qi_err, qx_err, qy_err, qz_err, bp_err, bq_err, br_err)
static inline void pprz_msg_send_AHRS_LKF_ACC_DBG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_qi_err, float *_qx_err, float *_qy_err, float *_qz_err, float *_bp_err, float *_bq_err, float *_br_err) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AHRS_LKF_ACC_DBG, "AHRS_LKF_ACC_DBG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _qi_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _qx_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _qy_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _qz_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bp_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bq_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _br_err);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AHRS_LKF_MAG_DBG(_trans, _dev, qi_err, qx_err, qy_err, qz_err, bp_err, bq_err, br_err) pprz_msg_send_AHRS_LKF_MAG_DBG(&((_trans).trans_tx), &((_dev).device), AC_ID, qi_err, qx_err, qy_err, qz_err, bp_err, bq_err, br_err)
static inline void pprz_msg_send_AHRS_LKF_MAG_DBG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_qi_err, float *_qx_err, float *_qy_err, float *_qz_err, float *_bp_err, float *_bq_err, float *_br_err) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AHRS_LKF_MAG_DBG, "AHRS_LKF_MAG_DBG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _qi_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _qx_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _qy_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _qz_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bp_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bq_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _br_err);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_NPS_SENSORS_SCALED(_trans, _dev, acc_x, acc_y, acc_z, mag_x, mag_y, mag_z) pprz_msg_send_NPS_SENSORS_SCALED(&((_trans).trans_tx), &((_dev).device), AC_ID, acc_x, acc_y, acc_z, mag_x, mag_y, mag_z)
static inline void pprz_msg_send_NPS_SENSORS_SCALED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_acc_x, float *_acc_y, float *_acc_z, float *_mag_x, float *_mag_y, float *_mag_z) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_NPS_SENSORS_SCALED, "NPS_SENSORS_SCALED");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _acc_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _acc_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _acc_z);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mag_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mag_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mag_z);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_INS(_trans, _dev, ins_x, ins_y, ins_z, ins_xd, ins_yd, ins_zd, ins_xdd, ins_ydd, ins_zdd) pprz_msg_send_INS(&((_trans).trans_tx), &((_dev).device), AC_ID, ins_x, ins_y, ins_z, ins_xd, ins_yd, ins_zd, ins_xdd, ins_ydd, ins_zdd)
static inline void pprz_msg_send_INS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_ins_x, int32_t *_ins_y, int32_t *_ins_z, int32_t *_ins_xd, int32_t *_ins_yd, int32_t *_ins_zd, int32_t *_ins_xdd, int32_t *_ins_ydd, int32_t *_ins_zdd) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_INS, "INS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ins_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ins_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ins_z);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ins_xd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ins_yd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ins_zd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ins_xdd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ins_ydd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ins_zdd);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_GPS_ERROR(_trans, _dev, x_position, y_position, z_position, x_velocity, y_velocity, z_velocity) pprz_msg_send_GPS_ERROR(&((_trans).trans_tx), &((_dev).device), AC_ID, x_position, y_position, z_position, x_velocity, y_velocity, z_velocity)
static inline void pprz_msg_send_GPS_ERROR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_x_position, float *_y_position, float *_z_position, float *_x_velocity, float *_y_velocity, float *_z_velocity) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_GPS_ERROR, "GPS_ERROR");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _x_position);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _y_position);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _z_position);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _x_velocity);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _y_velocity);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _z_velocity);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IMU_GYRO(_trans, _dev, gp, gq, gr) pprz_msg_send_IMU_GYRO(&((_trans).trans_tx), &((_dev).device), AC_ID, gp, gq, gr)
static inline void pprz_msg_send_IMU_GYRO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_gp, float *_gq, float *_gr) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IMU_GYRO, "IMU_GYRO");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _gp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _gq);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _gr);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IMU_MAG(_trans, _dev, mx, my, mz) pprz_msg_send_IMU_MAG(&((_trans).trans_tx), &((_dev).device), AC_ID, mx, my, mz)
static inline void pprz_msg_send_IMU_MAG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_mx, float *_my, float *_mz) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IMU_MAG, "IMU_MAG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _my);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _mz);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IMU_ACCEL(_trans, _dev, ax, ay, az) pprz_msg_send_IMU_ACCEL(&((_trans).trans_tx), &((_dev).device), AC_ID, ax, ay, az)
static inline void pprz_msg_send_IMU_ACCEL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_ax, float *_ay, float *_az) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IMU_ACCEL, "IMU_ACCEL");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ax);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ay);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _az);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IMU_GYRO_RAW(_trans, _dev, gp, gq, gr) pprz_msg_send_IMU_GYRO_RAW(&((_trans).trans_tx), &((_dev).device), AC_ID, gp, gq, gr)
static inline void pprz_msg_send_IMU_GYRO_RAW(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_gp, int32_t *_gq, int32_t *_gr) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IMU_GYRO_RAW, "IMU_GYRO_RAW");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _gp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _gq);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _gr);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IMU_ACCEL_RAW(_trans, _dev, ax, ay, az) pprz_msg_send_IMU_ACCEL_RAW(&((_trans).trans_tx), &((_dev).device), AC_ID, ax, ay, az)
static inline void pprz_msg_send_IMU_ACCEL_RAW(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_ax, int32_t *_ay, int32_t *_az) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IMU_ACCEL_RAW, "IMU_ACCEL_RAW");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ax);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ay);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _az);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IMU_MAG_RAW(_trans, _dev, mx, my, mz) pprz_msg_send_IMU_MAG_RAW(&((_trans).trans_tx), &((_dev).device), AC_ID, mx, my, mz)
static inline void pprz_msg_send_IMU_MAG_RAW(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_mx, int32_t *_my, int32_t *_mz) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IMU_MAG_RAW, "IMU_MAG_RAW");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _mx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _my);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _mz);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IMU_MAG_SETTINGS(_trans, _dev, inclination, declination, hardiron_x, hardiron_y, hardiron_z) pprz_msg_send_IMU_MAG_SETTINGS(&((_trans).trans_tx), &((_dev).device), AC_ID, inclination, declination, hardiron_x, hardiron_y, hardiron_z)
static inline void pprz_msg_send_IMU_MAG_SETTINGS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_inclination, float *_declination, float *_hardiron_x, float *_hardiron_y, float *_hardiron_z) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IMU_MAG_SETTINGS, "IMU_MAG_SETTINGS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _inclination);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _declination);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _hardiron_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _hardiron_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _hardiron_z);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IMU_MAG_CURRENT_CALIBRATION(_trans, _dev, mx, my, mz, electrical_current) pprz_msg_send_IMU_MAG_CURRENT_CALIBRATION(&((_trans).trans_tx), &((_dev).device), AC_ID, mx, my, mz, electrical_current)
static inline void pprz_msg_send_IMU_MAG_CURRENT_CALIBRATION(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_mx, int32_t *_my, int32_t *_mz, int32_t *_electrical_current) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IMU_MAG_CURRENT_CALIBRATION, "IMU_MAG_CURRENT_CALIBRATION");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _mx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _my);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _mz);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _electrical_current);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_UART_ERRORS(_trans, _dev, overrun_cnt, noise_err_cnt, framing_err_cnt, bus_number) pprz_msg_send_UART_ERRORS(&((_trans).trans_tx), &((_dev).device), AC_ID, overrun_cnt, noise_err_cnt, framing_err_cnt, bus_number)
static inline void pprz_msg_send_UART_ERRORS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_overrun_cnt, uint16_t *_noise_err_cnt, uint16_t *_framing_err_cnt, uint8_t *_bus_number) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_UART_ERRORS, "UART_ERRORS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _overrun_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _noise_err_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _framing_err_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _bus_number);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IMU_GYRO_LP(_trans, _dev, gp, gq, gr) pprz_msg_send_IMU_GYRO_LP(&((_trans).trans_tx), &((_dev).device), AC_ID, gp, gq, gr)
static inline void pprz_msg_send_IMU_GYRO_LP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_gp, float *_gq, float *_gr) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IMU_GYRO_LP, "IMU_GYRO_LP");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _gp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _gq);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _gr);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IMU_PRESSURE(_trans, _dev, p) pprz_msg_send_IMU_PRESSURE(&((_trans).trans_tx), &((_dev).device), AC_ID, p)
static inline void pprz_msg_send_IMU_PRESSURE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_p) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IMU_PRESSURE, "IMU_PRESSURE");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _p);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IMU_HS_GYRO(_trans, _dev, axis, nb_samples, samples) pprz_msg_send_IMU_HS_GYRO(&((_trans).trans_tx), &((_dev).device), AC_ID, axis, nb_samples, samples)
static inline void pprz_msg_send_IMU_HS_GYRO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_axis, uint8_t nb_samples, uint32_t *_samples) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+nb_samples*4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+nb_samples*4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+nb_samples*4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IMU_HS_GYRO, "IMU_HS_GYRO");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _axis);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_samples);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_ARRAY, 4 * nb_samples, (void *) _samples);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TEST_PASSTHROUGH_STATUS(_trans, _dev, io_proc_msg_cnt, io_proc_err_cnt, io_link_msg_cnt, io_link_err_cnt, rc_status) pprz_msg_send_TEST_PASSTHROUGH_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, io_proc_msg_cnt, io_proc_err_cnt, io_link_msg_cnt, io_link_err_cnt, rc_status)
static inline void pprz_msg_send_TEST_PASSTHROUGH_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_io_proc_msg_cnt, uint32_t *_io_proc_err_cnt, uint32_t *_io_link_msg_cnt, uint32_t *_io_link_err_cnt, uint8_t *_rc_status) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TEST_PASSTHROUGH_STATUS, "TEST_PASSTHROUGH_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _io_proc_msg_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _io_proc_err_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _io_link_msg_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _io_link_err_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _rc_status);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TUNE_VERT(_trans, _dev, z_sp, est_z, ref_z, ref_zd) pprz_msg_send_TUNE_VERT(&((_trans).trans_tx), &((_dev).device), AC_ID, z_sp, est_z, ref_z, ref_zd)
static inline void pprz_msg_send_TUNE_VERT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_z_sp, int32_t *_est_z, int32_t *_ref_z, int32_t *_ref_zd) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TUNE_VERT, "TUNE_VERT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _z_sp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _est_z);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_z);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _ref_zd);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_MF_DAQ_STATE(_trans, _dev, flight_time, p, q, r, phi, theta, psi, ax, ay, az, ve, vn, vu, lat, lon, alt, we, wn) pprz_msg_send_MF_DAQ_STATE(&((_trans).trans_tx), &((_dev).device), AC_ID, flight_time, p, q, r, phi, theta, psi, ax, ay, az, ve, vn, vu, lat, lon, alt, we, wn)
static inline void pprz_msg_send_MF_DAQ_STATE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_flight_time, float *_p, float *_q, float *_r, float *_phi, float *_theta, float *_psi, float *_ax, float *_ay, float *_az, float *_ve, float *_vn, float *_vu, float *_lat, float *_lon, float *_alt, float *_we, float *_wn) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_MF_DAQ_STATE, "MF_DAQ_STATE");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _flight_time);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ax);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ay);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _az);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ve);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _vn);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _vu);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _lat);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _lon);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _alt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _we);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _wn);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_INFO_MSG(_trans, _dev, nb_msg, msg) pprz_msg_send_INFO_MSG(&((_trans).trans_tx), &((_dev).device), AC_ID, nb_msg, msg)
static inline void pprz_msg_send_INFO_MSG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_msg, char *_msg) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_msg*1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_msg*1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+nb_msg*1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_INFO_MSG, "INFO_MSG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_msg);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_CHAR, DL_FORMAT_ARRAY, 1 * nb_msg, (void *) _msg);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_STAB_ATTITUDE_INDI(_trans, _dev, angular_accel_p, angular_accel_q, angular_accel_r, angular_accel_ref_p, angular_accel_ref_q, angular_accel_ref_r, g1_p, g1_q, g1_r, g2_r) pprz_msg_send_STAB_ATTITUDE_INDI(&((_trans).trans_tx), &((_dev).device), AC_ID, angular_accel_p, angular_accel_q, angular_accel_r, angular_accel_ref_p, angular_accel_ref_q, angular_accel_ref_r, g1_p, g1_q, g1_r, g2_r)
static inline void pprz_msg_send_STAB_ATTITUDE_INDI(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_angular_accel_p, float *_angular_accel_q, float *_angular_accel_r, float *_angular_accel_ref_p, float *_angular_accel_ref_q, float *_angular_accel_ref_r, float *_g1_p, float *_g1_q, float *_g1_r, float *_g2_r) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_STAB_ATTITUDE_INDI, "STAB_ATTITUDE_INDI");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _angular_accel_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _angular_accel_q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _angular_accel_r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _angular_accel_ref_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _angular_accel_ref_q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _angular_accel_ref_r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _g1_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _g1_q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _g1_r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _g2_r);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_BEBOP_ACTUATORS(_trans, _dev, cmd_thrust, cmd_roll, cmd_pitch, cmd_yaw, rpm_ref_lf, rpm_ref_rf, rpm_ref_rb, rpm_ref_lb, rpm_obs_lf, rpm_obs_rf, rpm_obs_rb, rpm_obs_lb) pprz_msg_send_BEBOP_ACTUATORS(&((_trans).trans_tx), &((_dev).device), AC_ID, cmd_thrust, cmd_roll, cmd_pitch, cmd_yaw, rpm_ref_lf, rpm_ref_rf, rpm_ref_rb, rpm_ref_lb, rpm_obs_lf, rpm_obs_rf, rpm_obs_rb, rpm_obs_lb)
static inline void pprz_msg_send_BEBOP_ACTUATORS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_cmd_thrust, int32_t *_cmd_roll, int32_t *_cmd_pitch, int32_t *_cmd_yaw, uint16_t *_rpm_ref_lf, uint16_t *_rpm_ref_rf, uint16_t *_rpm_ref_rb, uint16_t *_rpm_ref_lb, uint16_t *_rpm_obs_lf, uint16_t *_rpm_obs_rf, uint16_t *_rpm_obs_rb, uint16_t *_rpm_obs_lb) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+2+2+2+2+2+2+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+2+2+2+2+2+2+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+2+2+2+2+2+2+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_BEBOP_ACTUATORS, "BEBOP_ACTUATORS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cmd_thrust);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cmd_roll);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cmd_pitch);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT32, DL_FORMAT_SCALAR, 4, (void *) _cmd_yaw);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _rpm_ref_lf);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _rpm_ref_rf);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _rpm_ref_rb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _rpm_ref_lb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _rpm_obs_lf);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _rpm_obs_rf);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _rpm_obs_rb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _rpm_obs_lb);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_WEATHER(_trans, _dev, p_amb, t_amb, windspeed, wind_from, humidity) pprz_msg_send_WEATHER(&((_trans).trans_tx), &((_dev).device), AC_ID, p_amb, t_amb, windspeed, wind_from, humidity)
static inline void pprz_msg_send_WEATHER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_p_amb, float *_t_amb, float *_windspeed, float *_wind_from, float *_humidity) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_WEATHER, "WEATHER");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _p_amb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _t_amb);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _windspeed);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _wind_from);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _humidity);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_IMU_TURNTABLE(_trans, _dev, omega) pprz_msg_send_IMU_TURNTABLE(&((_trans).trans_tx), &((_dev).device), AC_ID, omega)
static inline void pprz_msg_send_IMU_TURNTABLE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_omega) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_IMU_TURNTABLE, "IMU_TURNTABLE");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _omega);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_BARO_RAW(_trans, _dev, abs, diff) pprz_msg_send_BARO_RAW(&((_trans).trans_tx), &((_dev).device), AC_ID, abs, diff)
static inline void pprz_msg_send_BARO_RAW(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_abs, float *_diff) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_BARO_RAW, "BARO_RAW");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _abs);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _diff);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AIR_DATA(_trans, _dev, pressure, diff_p, temp, qnh, amsl_baro, airspeed, tas) pprz_msg_send_AIR_DATA(&((_trans).trans_tx), &((_dev).device), AC_ID, pressure, diff_p, temp, qnh, amsl_baro, airspeed, tas)
static inline void pprz_msg_send_AIR_DATA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_pressure, float *_diff_p, float *_temp, float *_qnh, float *_amsl_baro, float *_airspeed, float *_tas) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AIR_DATA, "AIR_DATA");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pressure);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _diff_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _temp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _qnh);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _amsl_baro);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _airspeed);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _tas);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AMSL(_trans, _dev, AMSL_BARO, AMSL_GPS) pprz_msg_send_AMSL(&((_trans).trans_tx), &((_dev).device), AC_ID, AMSL_BARO, AMSL_GPS)
static inline void pprz_msg_send_AMSL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_AMSL_BARO, float *_AMSL_GPS) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AMSL, "AMSL");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _AMSL_BARO);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _AMSL_GPS);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_VIDEO_SYNC(_trans, _dev, id) pprz_msg_send_VIDEO_SYNC(&((_trans).trans_tx), &((_dev).device), AC_ID, id)
static inline void pprz_msg_send_VIDEO_SYNC(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_id) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_VIDEO_SYNC, "VIDEO_SYNC");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _id);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_PERIODIC_TELEMETRY_ERR(_trans, _dev, process, mode, id) pprz_msg_send_PERIODIC_TELEMETRY_ERR(&((_trans).trans_tx), &((_dev).device), AC_ID, process, mode, id)
static inline void pprz_msg_send_PERIODIC_TELEMETRY_ERR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_process, uint8_t *_mode, uint8_t *_id) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_PERIODIC_TELEMETRY_ERR, "PERIODIC_TELEMETRY_ERR");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _process);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _mode);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _id);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_TIME(_trans, _dev, t) pprz_msg_send_TIME(&((_trans).trans_tx), &((_dev).device), AC_ID, t)
static inline void pprz_msg_send_TIME(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_t) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_TIME, "TIME");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _t);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_OPTIC_FLOW_EST(_trans, _dev, fps, corner_cnt, tracked_cnt, flow_x, flow_y, flow_der_x, flow_der_y, vel_x, vel_y, div_size, surface_roughness, divergence) pprz_msg_send_OPTIC_FLOW_EST(&((_trans).trans_tx), &((_dev).device), AC_ID, fps, corner_cnt, tracked_cnt, flow_x, flow_y, flow_der_x, flow_der_y, vel_x, vel_y, div_size, surface_roughness, divergence)
static inline void pprz_msg_send_OPTIC_FLOW_EST(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_fps, uint16_t *_corner_cnt, uint16_t *_tracked_cnt, int16_t *_flow_x, int16_t *_flow_y, int16_t *_flow_der_x, int16_t *_flow_der_y, float *_vel_x, float *_vel_y, float *_div_size, float *_surface_roughness, float *_divergence) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+2+2+2+2+2+2+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+2+2+2+2+2+2+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+2+2+2+2+2+2+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_OPTIC_FLOW_EST, "OPTIC_FLOW_EST");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _fps);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _corner_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _tracked_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _flow_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _flow_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _flow_der_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _flow_der_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _vel_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _vel_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _div_size);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _surface_roughness);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _divergence);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_STEREO_IMG(_trans, _dev, frequency, data_size, nb_imageBuffer, imageBuffer) pprz_msg_send_STEREO_IMG(&((_trans).trans_tx), &((_dev).device), AC_ID, frequency, data_size, nb_imageBuffer, imageBuffer)
static inline void pprz_msg_send_STEREO_IMG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_frequency, uint8_t *_data_size, uint8_t nb_imageBuffer, uint8_t *_imageBuffer) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1+nb_imageBuffer*1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+1+nb_imageBuffer*1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+1+nb_imageBuffer*1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_STEREO_IMG, "STEREO_IMG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _frequency);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _data_size);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_imageBuffer);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_ARRAY, 1 * nb_imageBuffer, (void *) _imageBuffer);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_ROTORCRAFT_STATUS(_trans, _dev, link_imu_nb_err, motor_nb_err, rc_status, frame_rate, gps_status, ap_mode, ap_in_flight, ap_motors_on, ap_h_mode, ap_v_mode, vsupply, cpu_time) pprz_msg_send_ROTORCRAFT_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, link_imu_nb_err, motor_nb_err, rc_status, frame_rate, gps_status, ap_mode, ap_in_flight, ap_motors_on, ap_h_mode, ap_v_mode, vsupply, cpu_time)
static inline void pprz_msg_send_ROTORCRAFT_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_link_imu_nb_err, uint8_t *_motor_nb_err, uint8_t *_rc_status, uint8_t *_frame_rate, uint8_t *_gps_status, uint8_t *_ap_mode, uint8_t *_ap_in_flight, uint8_t *_ap_motors_on, uint8_t *_ap_h_mode, uint8_t *_ap_v_mode, uint16_t *_vsupply, uint16_t *_cpu_time) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+1+1+1+1+1+1+1+1+1+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+1+1+1+1+1+1+1+1+1+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+1+1+1+1+1+1+1+1+1+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_ROTORCRAFT_STATUS, "ROTORCRAFT_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _link_imu_nb_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _motor_nb_err);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _rc_status);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _frame_rate);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _gps_status);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ap_mode);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ap_in_flight);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ap_motors_on);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ap_h_mode);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _ap_v_mode);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _vsupply);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _cpu_time);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_STATE_FILTER_STATUS(_trans, _dev, id, state_filter_mode, value) pprz_msg_send_STATE_FILTER_STATUS(&((_trans).trans_tx), &((_dev).device), AC_ID, id, state_filter_mode, value)
static inline void pprz_msg_send_STATE_FILTER_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_id, uint8_t *_state_filter_mode, uint16_t *_value) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_STATE_FILTER_STATUS, "STATE_FILTER_STATUS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _state_filter_mode);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _value);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_PX4FLOW(_trans, _dev, sensor_id, flow_x, flow_y, flow_comp_m_x, flow_comp_m_y, quality, ground_distance) pprz_msg_send_PX4FLOW(&((_trans).trans_tx), &((_dev).device), AC_ID, sensor_id, flow_x, flow_y, flow_comp_m_x, flow_comp_m_y, quality, ground_distance)
static inline void pprz_msg_send_PX4FLOW(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_sensor_id, int16_t *_flow_x, int16_t *_flow_y, float *_flow_comp_m_x, float *_flow_comp_m_y, uint8_t *_quality, float *_ground_distance) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+2+2+4+4+1+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+2+2+4+4+1+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+2+2+4+4+1+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_PX4FLOW, "PX4FLOW");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _sensor_id);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _flow_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_INT16, DL_FORMAT_SCALAR, 2, (void *) _flow_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _flow_comp_m_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _flow_comp_m_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _quality);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ground_distance);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_OPTICFLOW(_trans, _dev, flow, ref_alt) pprz_msg_send_OPTICFLOW(&((_trans).trans_tx), &((_dev).device), AC_ID, flow, ref_alt)
static inline void pprz_msg_send_OPTICFLOW(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_flow, float *_ref_alt) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_OPTICFLOW, "OPTICFLOW");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _flow);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ref_alt);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_VISUALTARGET(_trans, _dev, x, y) pprz_msg_send_VISUALTARGET(&((_trans).trans_tx), &((_dev).device), AC_ID, x, y)
static inline void pprz_msg_send_VISUALTARGET(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_x, uint16_t *_y) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_VISUALTARGET, "VISUALTARGET");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _y);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_SONAR(_trans, _dev, sonar_meas, sonar_distance) pprz_msg_send_SONAR(&((_trans).trans_tx), &((_dev).device), AC_ID, sonar_meas, sonar_distance)
static inline void pprz_msg_send_SONAR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_sonar_meas, float *_sonar_distance) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_SONAR, "SONAR");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _sonar_meas);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _sonar_distance);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_PAYLOAD_FLOAT(_trans, _dev, nb_values, values) pprz_msg_send_PAYLOAD_FLOAT(&((_trans).trans_tx), &((_dev).device), AC_ID, nb_values, values)
static inline void pprz_msg_send_PAYLOAD_FLOAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_values, float *_values) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_values*4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+nb_values*4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+nb_values*4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_PAYLOAD_FLOAT, "PAYLOAD_FLOAT");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_ARRAY_LENGTH, DL_FORMAT_SCALAR, 1, (void *) &nb_values);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_ARRAY, 4 * nb_values, (void *) _values);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_NPS_POS_LLH(_trans, _dev, pprz_lat, lat_geod, lat_geoc, pprz_lon, lon, pprz_alt, alt_geod, agl, asl) pprz_msg_send_NPS_POS_LLH(&((_trans).trans_tx), &((_dev).device), AC_ID, pprz_lat, lat_geod, lat_geoc, pprz_lon, lon, pprz_alt, alt_geod, agl, asl)
static inline void pprz_msg_send_NPS_POS_LLH(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_pprz_lat, float *_lat_geod, float *_lat_geoc, float *_pprz_lon, float *_lon, float *_pprz_alt, float *_alt_geod, float *_agl, float *_asl) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_NPS_POS_LLH, "NPS_POS_LLH");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pprz_lat);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _lat_geod);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _lat_geoc);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pprz_lon);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _lon);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pprz_alt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _alt_geod);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _agl);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _asl);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_NPS_RPMS(_trans, _dev, front, back, right, left) pprz_msg_send_NPS_RPMS(&((_trans).trans_tx), &((_dev).device), AC_ID, front, back, right, left)
static inline void pprz_msg_send_NPS_RPMS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_front, float *_back, float *_right, float *_left) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_NPS_RPMS, "NPS_RPMS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _front);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _back);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _right);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _left);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_NPS_SPEED_POS(_trans, _dev, ltpp_xdd, ltpp_ydd, ltpp_zdd, ltpp_xd, ltpp_yd, ltpp_zd, ltpp_x, ltpp_y, ltpp_z) pprz_msg_send_NPS_SPEED_POS(&((_trans).trans_tx), &((_dev).device), AC_ID, ltpp_xdd, ltpp_ydd, ltpp_zdd, ltpp_xd, ltpp_yd, ltpp_zd, ltpp_x, ltpp_y, ltpp_z)
static inline void pprz_msg_send_NPS_SPEED_POS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_ltpp_xdd, float *_ltpp_ydd, float *_ltpp_zdd, float *_ltpp_xd, float *_ltpp_yd, float *_ltpp_zd, float *_ltpp_x, float *_ltpp_y, float *_ltpp_z) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_NPS_SPEED_POS, "NPS_SPEED_POS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ltpp_xdd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ltpp_ydd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ltpp_zdd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ltpp_xd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ltpp_yd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ltpp_zd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ltpp_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ltpp_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ltpp_z);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_NPS_RATE_ATTITUDE(_trans, _dev, p, q, r, phi, theta, psi) pprz_msg_send_NPS_RATE_ATTITUDE(&((_trans).trans_tx), &((_dev).device), AC_ID, p, q, r, phi, theta, psi)
static inline void pprz_msg_send_NPS_RATE_ATTITUDE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_p, float *_q, float *_r, float *_phi, float *_theta, float *_psi) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_NPS_RATE_ATTITUDE, "NPS_RATE_ATTITUDE");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _psi);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_NPS_GYRO_BIAS(_trans, _dev, bp, bq, br) pprz_msg_send_NPS_GYRO_BIAS(&((_trans).trans_tx), &((_dev).device), AC_ID, bp, bq, br)
static inline void pprz_msg_send_NPS_GYRO_BIAS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_bp, float *_bq, float *_br) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_NPS_GYRO_BIAS, "NPS_GYRO_BIAS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bp);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _bq);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _br);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_NPS_RANGE_METER(_trans, _dev, dist) pprz_msg_send_NPS_RANGE_METER(&((_trans).trans_tx), &((_dev).device), AC_ID, dist)
static inline void pprz_msg_send_NPS_RANGE_METER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_dist) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_NPS_RANGE_METER, "NPS_RANGE_METER");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _dist);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_NPS_WIND(_trans, _dev, vx, vy, vz) pprz_msg_send_NPS_WIND(&((_trans).trans_tx), &((_dev).device), AC_ID, vx, vy, vz)
static inline void pprz_msg_send_NPS_WIND(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_vx, float *_vy, float *_vz) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_NPS_WIND, "NPS_WIND");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _vx);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _vy);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _vz);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_PPRZ_DEBUG(_trans, _dev, module, errno) pprz_msg_send_PPRZ_DEBUG(&((_trans).trans_tx), &((_dev).device), AC_ID, module, errno)
static inline void pprz_msg_send_PPRZ_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_module, uint8_t *_errno) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_PPRZ_DEBUG, "PPRZ_DEBUG");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _module);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _errno);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_NPS_ACCEL_LTP(_trans, _dev, xdd, ydd, zdd) pprz_msg_send_NPS_ACCEL_LTP(&((_trans).trans_tx), &((_dev).device), AC_ID, xdd, ydd, zdd)
static inline void pprz_msg_send_NPS_ACCEL_LTP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_xdd, float *_ydd, float *_zdd) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_NPS_ACCEL_LTP, "NPS_ACCEL_LTP");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _xdd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _ydd);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _zdd);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_LOOSE_INS_GPS(_trans, _dev, status, time_running, q0, q1, q2, q3, phi, theta, psi, north, east, down, v_north, v_east, v_down, est_p, est_q, est_r, gyroBias_x, gyroBias_y, gyroBias_z, imuCallbacks, gpsCallbacks, baroCallbacks) pprz_msg_send_LOOSE_INS_GPS(&((_trans).trans_tx), &((_dev).device), AC_ID, status, time_running, q0, q1, q2, q3, phi, theta, psi, north, east, down, v_north, v_east, v_down, est_p, est_q, est_r, gyroBias_x, gyroBias_y, gyroBias_z, imuCallbacks, gpsCallbacks, baroCallbacks)
static inline void pprz_msg_send_LOOSE_INS_GPS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_status, double *_time_running, double *_q0, double *_q1, double *_q2, double *_q3, double *_phi, double *_theta, double *_psi, double *_north, double *_east, double *_down, double *_v_north, double *_v_east, double *_v_down, double *_est_p, double *_est_q, double *_est_r, double *_gyroBias_x, double *_gyroBias_y, double *_gyroBias_z, uint32_t *_imuCallbacks, uint32_t *_gpsCallbacks, uint32_t *_baroCallbacks) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+1+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+1+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+1+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+8+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_LOOSE_INS_GPS, "LOOSE_INS_GPS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _status);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _time_running);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _q0);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _q1);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _q2);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _q3);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _north);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _east);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _down);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _v_north);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _v_east);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _v_down);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _est_p);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _est_q);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _est_r);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _gyroBias_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _gyroBias_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _gyroBias_z);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _imuCallbacks);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _gpsCallbacks);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _baroCallbacks);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_AFL_COEFFS(_trans, _dev, roll_a, roll_b, roll_c, pitch_a, pitch_b, pitch_c, yaw_a, yaw_b, yaw_c) pprz_msg_send_AFL_COEFFS(&((_trans).trans_tx), &((_dev).device), AC_ID, roll_a, roll_b, roll_c, pitch_a, pitch_b, pitch_c, yaw_a, yaw_b, yaw_c)
static inline void pprz_msg_send_AFL_COEFFS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_roll_a, float *_roll_b, float *_roll_c, float *_pitch_a, float *_pitch_b, float *_pitch_c, float *_yaw_a, float *_yaw_b, float *_yaw_c) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_AFL_COEFFS, "AFL_COEFFS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _roll_a);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _roll_b);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _roll_c);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pitch_a);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pitch_b);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _pitch_c);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _yaw_a);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _yaw_b);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _yaw_c);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_I2C_ERRORS(_trans, _dev, wd_reset_cnt, queue_full_cnt, acknowledge_failure_cnt, misplaced_start_or_stop_cnt, arbitration_lost_cnt, overrun_or_underrun_cnt, pec_error_in_reception_cnt, timeout_or_tlow_error_cnt, smbus_alert_cnt, unexpected_event_cnt, last_unexpected_event, bus_number) pprz_msg_send_I2C_ERRORS(&((_trans).trans_tx), &((_dev).device), AC_ID, wd_reset_cnt, queue_full_cnt, acknowledge_failure_cnt, misplaced_start_or_stop_cnt, arbitration_lost_cnt, overrun_or_underrun_cnt, pec_error_in_reception_cnt, timeout_or_tlow_error_cnt, smbus_alert_cnt, unexpected_event_cnt, last_unexpected_event, bus_number)
static inline void pprz_msg_send_I2C_ERRORS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_wd_reset_cnt, uint16_t *_queue_full_cnt, uint16_t *_acknowledge_failure_cnt, uint16_t *_misplaced_start_or_stop_cnt, uint16_t *_arbitration_lost_cnt, uint16_t *_overrun_or_underrun_cnt, uint16_t *_pec_error_in_reception_cnt, uint16_t *_timeout_or_tlow_error_cnt, uint16_t *_smbus_alert_cnt, uint16_t *_unexpected_event_cnt, uint32_t *_last_unexpected_event, uint8_t *_bus_number) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+2+2+2+2+4+1 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+2+2+2+2+2+2+2+2+2+2+4+1 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+2+2+2+2+2+2+2+2+2+2+4+1 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_I2C_ERRORS, "I2C_ERRORS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _wd_reset_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _queue_full_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _acknowledge_failure_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _misplaced_start_or_stop_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _arbitration_lost_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _overrun_or_underrun_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _pec_error_in_reception_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _timeout_or_tlow_error_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _smbus_alert_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT16, DL_FORMAT_SCALAR, 2, (void *) _unexpected_event_cnt);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _last_unexpected_event);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _bus_number);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_RDYB_TRAJECTORY(_trans, _dev, commanded_phi, commanded_theta, commanded_psi, setpoint_x, setpoint_y, setpoint_z) pprz_msg_send_RDYB_TRAJECTORY(&((_trans).trans_tx), &((_dev).device), AC_ID, commanded_phi, commanded_theta, commanded_psi, setpoint_x, setpoint_y, setpoint_z)
static inline void pprz_msg_send_RDYB_TRAJECTORY(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_commanded_phi, float *_commanded_theta, float *_commanded_psi, float *_setpoint_x, float *_setpoint_y, float *_setpoint_z) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+4+4+4+4+4 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+4+4+4+4+4 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_RDYB_TRAJECTORY, "RDYB_TRAJECTORY");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _commanded_phi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _commanded_theta);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _commanded_psi);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _setpoint_x);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _setpoint_y);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_FLOAT, DL_FORMAT_SCALAR, 4, (void *) _setpoint_z);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#define DOWNLINK_SEND_HENRY_GNSS(_trans, _dev, last_imu_update, GPS_time, GPS_solution_valid, latitude, longitude, altitude, North, East, Down, SVs_Tracked, SVs_PVT, V_North, V_East, V_Down) pprz_msg_send_HENRY_GNSS(&((_trans).trans_tx), &((_dev).device), AC_ID, last_imu_update, GPS_time, GPS_solution_valid, latitude, longitude, altitude, North, East, Down, SVs_Tracked, SVs_PVT, V_North, V_East, V_Down)
static inline void pprz_msg_send_HENRY_GNSS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_last_imu_update, double *_GPS_time, uint8_t *_GPS_solution_valid, double *_latitude, double *_longitude, double *_altitude, double *_North, double *_East, double *_Down, uint8_t *_SVs_Tracked, uint8_t *_SVs_PVT, double *_V_North, double *_V_East, double *_V_Down) {
	if (trans->check_available_space(trans->impl, dev, trans->size_of(trans->impl, 0+4+8+1+8+8+8+8+8+8+1+1+8+8+8 +2 /* msg header overhead */))) {
	  trans->count_bytes(trans->impl, dev, trans->size_of(trans->impl, 0+4+8+1+8+8+8+8+8+8+1+1+8+8+8 +2 /* msg header overhead */));
	  trans->start_message(trans->impl, dev, 0+4+8+1+8+8+8+8+8+8+1+1+8+8+8 +2 /* msg header overhead */);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, &ac_id);
	  trans->put_named_byte(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, DL_HENRY_GNSS, "HENRY_GNSS");
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT32, DL_FORMAT_SCALAR, 4, (void *) _last_imu_update);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _GPS_time);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _GPS_solution_valid);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _latitude);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _longitude);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _altitude);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _North);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _East);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _Down);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _SVs_Tracked);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_UINT8, DL_FORMAT_SCALAR, 1, (void *) _SVs_PVT);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _V_North);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _V_East);
	  trans->put_bytes(trans->impl, dev, DL_TYPE_DOUBLE, DL_FORMAT_SCALAR, 8, (void *) _V_Down);
	  trans->end_message(trans->impl, dev);
	} else
	  trans->overrun(trans->impl, dev);
}

#else // DOWNLINK
#define DOWNLINK_SEND_AUTOPILOT_VERSION(_trans, _dev, version, nb_desc, desc) {}
static inline void pprz_msg_send_AUTOPILOT_VERSION(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_version, uint8_t nb_desc, char *_desc) {}
#define DOWNLINK_SEND_ALIVE(_trans, _dev, nb_md5sum, md5sum) {}
static inline void pprz_msg_send_ALIVE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_md5sum, uint8_t *_md5sum) {}
#define DOWNLINK_SEND_PONG(_trans, _dev) {}
static inline void pprz_msg_send_PONG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id) {}
#define DOWNLINK_SEND_TAKEOFF(_trans, _dev, cpu_time) {}
static inline void pprz_msg_send_TAKEOFF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_cpu_time) {}
#define DOWNLINK_SEND_ARDRONE_NAVDATA(_trans, _dev, taille, nu_trame, ax, ay, az, vx, vy, vz, temperature_acc, temperature_gyro, ultrasound, us_debut_echo, us_fin_echo, us_association_echo, us_distance_echo, us_curve_time, us_curve_value, us_curve_ref, nb_echo, sum_echo, gradient, flag_echo_ini, pressure, temperature_pressure, mx, my, mz, chksum, checksum_errors) {}
static inline void pprz_msg_send_ARDRONE_NAVDATA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_taille, uint16_t *_nu_trame, uint16_t *_ax, uint16_t *_ay, uint16_t *_az, int16_t *_vx, int16_t *_vy, int16_t *_vz, uint16_t *_temperature_acc, uint16_t *_temperature_gyro, uint16_t *_ultrasound, uint16_t *_us_debut_echo, uint16_t *_us_fin_echo, uint16_t *_us_association_echo, uint16_t *_us_distance_echo, uint16_t *_us_curve_time, uint16_t *_us_curve_value, uint16_t *_us_curve_ref, uint16_t *_nb_echo, uint32_t *_sum_echo, int16_t *_gradient, uint16_t *_flag_echo_ini, int32_t *_pressure, uint16_t *_temperature_pressure, int16_t *_mx, int16_t *_my, int16_t *_mz, uint16_t *_chksum, uint32_t *_checksum_errors) {}
#define DOWNLINK_SEND_ATTITUDE(_trans, _dev, phi, psi, theta) {}
static inline void pprz_msg_send_ATTITUDE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_phi, float *_psi, float *_theta) {}
#define DOWNLINK_SEND_IR_SENSORS(_trans, _dev, ir1, ir2, longitudinal, lateral, vertical) {}
static inline void pprz_msg_send_IR_SENSORS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_ir1, int16_t *_ir2, int16_t *_longitudinal, int16_t *_lateral, int16_t *_vertical) {}
#define DOWNLINK_SEND_GPS(_trans, _dev, mode, utm_east, utm_north, course, alt, speed, climb, week, itow, utm_zone, gps_nb_err) {}
static inline void pprz_msg_send_GPS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_mode, int32_t *_utm_east, int32_t *_utm_north, int16_t *_course, int32_t *_alt, uint16_t *_speed, int16_t *_climb, uint16_t *_week, uint32_t *_itow, uint8_t *_utm_zone, uint8_t *_gps_nb_err) {}
#define DOWNLINK_SEND_NAVIGATION_REF(_trans, _dev, utm_east, utm_north, utm_zone, ground_alt) {}
static inline void pprz_msg_send_NAVIGATION_REF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_utm_east, int32_t *_utm_north, uint8_t *_utm_zone, float *_ground_alt) {}
#define DOWNLINK_SEND_NAVIGATION(_trans, _dev, cur_block, cur_stage, pos_x, pos_y, dist_wp, dist_home, circle_count, oval_count) {}
static inline void pprz_msg_send_NAVIGATION(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_cur_block, uint8_t *_cur_stage, float *_pos_x, float *_pos_y, float *_dist_wp, float *_dist_home, uint8_t *_circle_count, uint8_t *_oval_count) {}
#define DOWNLINK_SEND_PPRZ_MODE(_trans, _dev, ap_mode, ap_gaz, ap_lateral, ap_horizontal, if_calib_mode, mcu1_status) {}
static inline void pprz_msg_send_PPRZ_MODE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ap_mode, uint8_t *_ap_gaz, uint8_t *_ap_lateral, uint8_t *_ap_horizontal, uint8_t *_if_calib_mode, uint8_t *_mcu1_status) {}
#define DOWNLINK_SEND_BAT(_trans, _dev, throttle, voltage, amps, flight_time, kill_auto_throttle, block_time, stage_time, energy) {}
static inline void pprz_msg_send_BAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_throttle, uint16_t *_voltage, int16_t *_amps, uint16_t *_flight_time, uint8_t *_kill_auto_throttle, uint16_t *_block_time, uint16_t *_stage_time, int16_t *_energy) {}
#define DOWNLINK_SEND_DEBUG_MCU_LINK(_trans, _dev, i2c_nb_err, i2c_mcu1_nb_err, ppm_rate) {}
static inline void pprz_msg_send_DEBUG_MCU_LINK(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_i2c_nb_err, uint8_t *_i2c_mcu1_nb_err, uint8_t *_ppm_rate) {}
#define DOWNLINK_SEND_CALIBRATION(_trans, _dev, climb_sum_err, climb_gaz_submode) {}
static inline void pprz_msg_send_CALIBRATION(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_climb_sum_err, uint8_t *_climb_gaz_submode) {}
#define DOWNLINK_SEND_SETTINGS(_trans, _dev, slider_1_val, slider_2_val) {}
static inline void pprz_msg_send_SETTINGS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_slider_1_val, float *_slider_2_val) {}
#define DOWNLINK_SEND_DESIRED(_trans, _dev, roll, pitch, course, x, y, altitude, climb, airspeed) {}
static inline void pprz_msg_send_DESIRED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_roll, float *_pitch, float *_course, float *_x, float *_y, float *_altitude, float *_climb, float *_airspeed) {}
#define DOWNLINK_SEND_GPS_SOL(_trans, _dev, Pacc, Sacc, PDOP, numSV) {}
static inline void pprz_msg_send_GPS_SOL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_Pacc, uint32_t *_Sacc, uint16_t *_PDOP, uint8_t *_numSV) {}
#define DOWNLINK_SEND_ADC_GENERIC(_trans, _dev, val1, val2) {}
static inline void pprz_msg_send_ADC_GENERIC(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_val1, uint16_t *_val2) {}
#define DOWNLINK_SEND_TEST_FORMAT(_trans, _dev, val1, val2) {}
static inline void pprz_msg_send_TEST_FORMAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, double *_val1, float *_val2) {}
#define DOWNLINK_SEND_CAM(_trans, _dev, phi, theta, target_x, target_y) {}
static inline void pprz_msg_send_CAM(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_phi, int16_t *_theta, int16_t *_target_x, int16_t *_target_y) {}
#define DOWNLINK_SEND_CIRCLE(_trans, _dev, center_east, center_north, radius) {}
static inline void pprz_msg_send_CIRCLE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_center_east, float *_center_north, float *_radius) {}
#define DOWNLINK_SEND_SEGMENT(_trans, _dev, segment_east_1, segment_north_1, segment_east_2, segment_north_2) {}
static inline void pprz_msg_send_SEGMENT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_segment_east_1, float *_segment_north_1, float *_segment_east_2, float *_segment_north_2) {}
#define DOWNLINK_SEND_VECTORNAV_INFO(_trans, _dev, timestamp, chksm_error, hdr_error, counter, ins_status, ins_err, YprU1, YprU2, YprU3) {}
static inline void pprz_msg_send_VECTORNAV_INFO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_timestamp, uint32_t *_chksm_error, uint32_t *_hdr_error, uint16_t *_counter, uint8_t *_ins_status, uint8_t *_ins_err, float *_YprU1, float *_YprU2, float *_YprU3) {}
#define DOWNLINK_SEND_SVINFO(_trans, _dev, chn, SVID, Flags, QI, CNO, Elev, Azim) {}
static inline void pprz_msg_send_SVINFO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_chn, uint8_t *_SVID, uint8_t *_Flags, uint8_t *_QI, uint8_t *_CNO, int8_t *_Elev, int16_t *_Azim) {}
#define DOWNLINK_SEND_DEBUG(_trans, _dev, nb_msg, msg) {}
static inline void pprz_msg_send_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_msg, uint8_t *_msg) {}
#define DOWNLINK_SEND_SURVEY(_trans, _dev, east, north, west, south) {}
static inline void pprz_msg_send_SURVEY(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_east, float *_north, float *_west, float *_south) {}
#define DOWNLINK_SEND_WC_RSSI(_trans, _dev, raw_level) {}
static inline void pprz_msg_send_WC_RSSI(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_raw_level) {}
#define DOWNLINK_SEND_RANGEFINDER(_trans, _dev, range, z_dot, z_dot_sum_err, z_dot_setpoint, z_sum_err, z_setpoint, flying) {}
static inline void pprz_msg_send_RANGEFINDER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_range, float *_z_dot, float *_z_dot_sum_err, float *_z_dot_setpoint, float *_z_sum_err, float *_z_setpoint, uint8_t *_flying) {}
#define DOWNLINK_SEND_DATALINK_REPORT(_trans, _dev, uplink_lost_time, uplink_nb_msgs, downlink_nb_msgs, downlink_rate, uplink_rate, downlink_ovrn) {}
static inline void pprz_msg_send_DATALINK_REPORT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_uplink_lost_time, uint16_t *_uplink_nb_msgs, uint16_t *_downlink_nb_msgs, uint16_t *_downlink_rate, uint16_t *_uplink_rate, uint8_t *_downlink_ovrn) {}
#define DOWNLINK_SEND_DL_VALUE(_trans, _dev, index, value) {}
static inline void pprz_msg_send_DL_VALUE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_index, float *_value) {}
#define DOWNLINK_SEND_MARK(_trans, _dev, ac_id, lat, long) {}
static inline void pprz_msg_send_MARK(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id, float *_lat, float *_long) {}
#define DOWNLINK_SEND_SYS_MON(_trans, _dev, periodic_time, periodic_time_min, periodic_time_max, periodic_cycle, periodic_cycle_min, periodic_cycle_max, event_number, cpu_load) {}
static inline void pprz_msg_send_SYS_MON(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_periodic_time, uint16_t *_periodic_time_min, uint16_t *_periodic_time_max, uint16_t *_periodic_cycle, uint16_t *_periodic_cycle_min, uint16_t *_periodic_cycle_max, uint16_t *_event_number, uint8_t *_cpu_load) {}
#define DOWNLINK_SEND_MOTOR(_trans, _dev, rpm, current) {}
static inline void pprz_msg_send_MOTOR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_rpm, int32_t *_current) {}
#define DOWNLINK_SEND_WP_MOVED(_trans, _dev, wp_id, utm_east, utm_north, alt, utm_zone) {}
static inline void pprz_msg_send_WP_MOVED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_wp_id, float *_utm_east, float *_utm_north, float *_alt, uint8_t *_utm_zone) {}
#define DOWNLINK_SEND_MKK(_trans, _dev, nr, rpm, current, temp) {}
static inline void pprz_msg_send_MKK(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_nr, uint8_t *_rpm, uint8_t *_current, int8_t *_temp) {}
#define DOWNLINK_SEND_ENERGY(_trans, _dev, bat, amp, energy, power) {}
static inline void pprz_msg_send_ENERGY(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_bat, float *_amp, uint16_t *_energy, float *_power) {}
#define DOWNLINK_SEND_BARO_BMP85_CALIB(_trans, _dev, a1, a2, a3, a4, a5, a6, b1, b2, mb, mc, md) {}
static inline void pprz_msg_send_BARO_BMP85_CALIB(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_a1, int16_t *_a2, int16_t *_a3, uint16_t *_a4, uint16_t *_a5, uint16_t *_a6, int16_t *_b1, int16_t *_b2, int16_t *_mb, int16_t *_mc, int16_t *_md) {}
#define DOWNLINK_SEND_BARO_BMP85(_trans, _dev, UT, UP, P, T, MSL) {}
static inline void pprz_msg_send_BARO_BMP85(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_UT, int32_t *_UP, uint32_t *_P, float *_T, float *_MSL) {}
#define DOWNLINK_SEND_SPEED_LOOP(_trans, _dev, ve_set_point, ve, vn_set_point, vn, north_sp, east_sp) {}
static inline void pprz_msg_send_SPEED_LOOP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_ve_set_point, float *_ve, float *_vn_set_point, float *_vn, float *_north_sp, float *_east_sp) {}
#define DOWNLINK_SEND_ALT_KALMAN(_trans, _dev, p00, p01, p10, p11) {}
static inline void pprz_msg_send_ALT_KALMAN(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_p00, float *_p01, float *_p10, float *_p11) {}
#define DOWNLINK_SEND_ESTIMATOR(_trans, _dev, z, z_dot) {}
static inline void pprz_msg_send_ESTIMATOR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_z, float *_z_dot) {}
#define DOWNLINK_SEND_TUNE_ROLL(_trans, _dev, p, phi, phi_sp) {}
static inline void pprz_msg_send_TUNE_ROLL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_p, float *_phi, float *_phi_sp) {}
#define DOWNLINK_SEND_BARO_MS5534A(_trans, _dev, pressure, temp, alt) {}
static inline void pprz_msg_send_BARO_MS5534A(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_pressure, uint16_t *_temp, float *_alt) {}
#define DOWNLINK_SEND_PRESSURE(_trans, _dev, airspeed_adc, airspeed, altitude_adc, altitude) {}
static inline void pprz_msg_send_PRESSURE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_airspeed_adc, float *_airspeed, float *_altitude_adc, float *_altitude) {}
#define DOWNLINK_SEND_BARO_WORDS(_trans, _dev, w1, w2, w3, w4) {}
static inline void pprz_msg_send_BARO_WORDS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_w1, uint16_t *_w2, uint16_t *_w3, uint16_t *_w4) {}
#define DOWNLINK_SEND_WP_MOVED_LLA(_trans, _dev, wp_id, lat, lon, alt) {}
static inline void pprz_msg_send_WP_MOVED_LLA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_wp_id, int32_t *_lat, int32_t *_lon, int32_t *_alt) {}
#define DOWNLINK_SEND_CHRONO(_trans, _dev, tag, time) {}
static inline void pprz_msg_send_CHRONO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_tag, uint32_t *_time) {}
#define DOWNLINK_SEND_WP_MOVED_ENU(_trans, _dev, wp_id, east, north, up) {}
static inline void pprz_msg_send_WP_MOVED_ENU(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_wp_id, int32_t *_east, int32_t *_north, int32_t *_up) {}
#define DOWNLINK_SEND_WINDTURBINE_STATUS_(_trans, _dev, ac_id, tb_id, sync_itow, cycle_time) {}
static inline void pprz_msg_send_WINDTURBINE_STATUS_(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id, uint8_t *_tb_id, uint32_t *_sync_itow, uint32_t *_cycle_time) {}
#define DOWNLINK_SEND_RC_3CH_(_trans, _dev, throttle_mode, roll, pitch) {}
static inline void pprz_msg_send_RC_3CH_(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_throttle_mode, int8_t *_roll, int8_t *_pitch) {}
#define DOWNLINK_SEND_MPPT(_trans, _dev, nb_values, values) {}
static inline void pprz_msg_send_MPPT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_values, int16_t *_values) {}
#define DOWNLINK_SEND_DEBUG_IR_I2C(_trans, _dev, ir1, ir2, top) {}
static inline void pprz_msg_send_DEBUG_IR_I2C(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_ir1, int16_t *_ir2, int16_t *_top) {}
#define DOWNLINK_SEND_AIRSPEED(_trans, _dev, airspeed, airspeed_sp, airspeed_cnt, groundspeed_sp) {}
static inline void pprz_msg_send_AIRSPEED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_airspeed, float *_airspeed_sp, float *_airspeed_cnt, float *_groundspeed_sp) {}
#define DOWNLINK_SEND_XSENS(_trans, _dev, counter, p, q, r, phi, theta, psi, ax, ay, az, vx, vy, vz, lat, lon, alt, status, hour, min, sec, nanosec, year, month, day) {}
static inline void pprz_msg_send_XSENS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_counter, float *_p, float *_q, float *_r, float *_phi, float *_theta, float *_psi, float *_ax, float *_ay, float *_az, float *_vx, float *_vy, float *_vz, float *_lat, float *_lon, float *_alt, uint8_t *_status, uint8_t *_hour, uint8_t *_min, uint8_t *_sec, uint32_t *_nanosec, uint16_t *_year, uint8_t *_month, uint8_t *_day) {}
#define DOWNLINK_SEND_BARO_ETS(_trans, _dev, adc, offset, scaled) {}
static inline void pprz_msg_send_BARO_ETS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_adc, uint16_t *_offset, float *_scaled) {}
#define DOWNLINK_SEND_AIRSPEED_ETS(_trans, _dev, adc, offset, scaled) {}
static inline void pprz_msg_send_AIRSPEED_ETS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_adc, uint16_t *_offset, float *_scaled) {}
#define DOWNLINK_SEND_PBN(_trans, _dev, airspeed_adc, altitude_adc, airspeed, altitude, airspeed_offset, altitude_offset) {}
static inline void pprz_msg_send_PBN(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_airspeed_adc, uint16_t *_altitude_adc, float *_airspeed, float *_altitude, uint16_t *_airspeed_offset, uint16_t *_altitude_offset) {}
#define DOWNLINK_SEND_GPS_LLA(_trans, _dev, lat, lon, alt, hmsl, course, speed, climb, week, itow, mode, gps_nb_err) {}
static inline void pprz_msg_send_GPS_LLA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_lat, int32_t *_lon, int32_t *_alt, int32_t *_hmsl, int16_t *_course, uint16_t *_speed, int16_t *_climb, uint16_t *_week, uint32_t *_itow, uint8_t *_mode, uint8_t *_gps_nb_err) {}
#define DOWNLINK_SEND_H_CTL_A(_trans, _dev, roll_sum_err, roll_sp, roll_ref, phi, aileron_sp, pitch_sum_err, pitch_sp, pitch_ref, theta, elevator_sp) {}
static inline void pprz_msg_send_H_CTL_A(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_roll_sum_err, float *_roll_sp, float *_roll_ref, float *_phi, int16_t *_aileron_sp, float *_pitch_sum_err, float *_pitch_sp, float *_pitch_ref, float *_theta, int16_t *_elevator_sp) {}
#define DOWNLINK_SEND_TURB_PRESSURE_RAW(_trans, _dev, ch_0, ch_1, ch_2, ch_3, ch_4, ch_5, ch_6, ch_7, ch_8, ch_9, ch_10, ch_11, ch_12, ch_13, ch_14, ch_15) {}
static inline void pprz_msg_send_TURB_PRESSURE_RAW(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_ch_0, int32_t *_ch_1, int32_t *_ch_2, int32_t *_ch_3, int32_t *_ch_4, int32_t *_ch_5, int32_t *_ch_6, int32_t *_ch_7, int32_t *_ch_8, int32_t *_ch_9, int32_t *_ch_10, int32_t *_ch_11, int32_t *_ch_12, int32_t *_ch_13, int32_t *_ch_14, int32_t *_ch_15) {}
#define DOWNLINK_SEND_TURB_PRESSURE_VOLTAGE(_trans, _dev, ch_1_p, ch_1_t, ch_2_p, ch_2_t, ch_3_p, ch_3_t, ch_4_p, ch_4_t, ch_5_p, ch_5_t, ch_6_p, ch_6_t, ch_7_p, ch_7_t, gnd1, gnd2) {}
static inline void pprz_msg_send_TURB_PRESSURE_VOLTAGE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_ch_1_p, float *_ch_1_t, float *_ch_2_p, float *_ch_2_t, float *_ch_3_p, float *_ch_3_t, float *_ch_4_p, float *_ch_4_t, float *_ch_5_p, float *_ch_5_t, float *_ch_6_p, float *_ch_6_t, float *_ch_7_p, float *_ch_7_t, float *_gnd1, float *_gnd2) {}
#define DOWNLINK_SEND_CAM_POINT(_trans, _dev, cam_point_distance_from_home, cam_point_lat, cam_point_lon) {}
static inline void pprz_msg_send_CAM_POINT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_cam_point_distance_from_home, float *_cam_point_lat, float *_cam_point_lon) {}
#define DOWNLINK_SEND_DC_INFO(_trans, _dev, mode, lat, lon, alt, course, photo_nr, dist, next_dist, start_x, start_y, start_angle, angle, last_block, count, shutter) {}
static inline void pprz_msg_send_DC_INFO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_mode, int32_t *_lat, int32_t *_lon, int32_t *_alt, float *_course, uint16_t *_photo_nr, float *_dist, float *_next_dist, float *_start_x, float *_start_y, float *_start_angle, float *_angle, float *_last_block, uint16_t *_count, uint8_t *_shutter) {}
#define DOWNLINK_SEND_AMSYS_BARO(_trans, _dev, pBaroRaw, pBaro, pHomePressure, AltOffset, aktuell, Over_Ground, tempBaro) {}
static inline void pprz_msg_send_AMSYS_BARO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_pBaroRaw, float *_pBaro, float *_pHomePressure, float *_AltOffset, float *_aktuell, float *_Over_Ground, float *_tempBaro) {}
#define DOWNLINK_SEND_AMSYS_AIRSPEED(_trans, _dev, asRaw, asPresure, asAirspeed, asAirsFilt, asTemp) {}
static inline void pprz_msg_send_AMSYS_AIRSPEED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_asRaw, float *_asPresure, float *_asAirspeed, float *_asAirsFilt, float *_asTemp) {}
#define DOWNLINK_SEND_FLIGHT_BENCHMARK(_trans, _dev, SE_As, SE_Alt, SE_Pos, Err_As, Err_Alt, Err_Pos) {}
static inline void pprz_msg_send_FLIGHT_BENCHMARK(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_SE_As, float *_SE_Alt, float *_SE_Pos, float *_Err_As, float *_Err_Alt, float *_Err_Pos) {}
#define DOWNLINK_SEND_MPL3115_BARO(_trans, _dev, pressure, temp, alt) {}
static inline void pprz_msg_send_MPL3115_BARO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_pressure, int16_t *_temp, float *_alt) {}
#define DOWNLINK_SEND_AOA(_trans, _dev, raw, angle) {}
static inline void pprz_msg_send_AOA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_raw, float *_angle) {}
#define DOWNLINK_SEND_XTEND_RSSI(_trans, _dev, datalink_time, rssi_fade_margin, duty) {}
static inline void pprz_msg_send_XTEND_RSSI(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_datalink_time, uint8_t *_rssi_fade_margin, uint8_t *_duty) {}
#define DOWNLINK_SEND_SUPERBITRF(_trans, _dev, status, cyrf_status, irq_count, rx_packet_count, tx_packet_count, transfer_timeouts, resync_count, uplink_count, rc_count, timing1, timing2, bind_mfg_id, nb_mfg_id, mfg_id) {}
static inline void pprz_msg_send_SUPERBITRF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_status, uint8_t *_cyrf_status, uint32_t *_irq_count, uint32_t *_rx_packet_count, uint32_t *_tx_packet_count, uint32_t *_transfer_timeouts, uint32_t *_resync_count, uint32_t *_uplink_count, uint32_t *_rc_count, uint32_t *_timing1, uint32_t *_timing2, uint32_t *_bind_mfg_id, uint8_t nb_mfg_id, uint8_t *_mfg_id) {}
#define DOWNLINK_SEND_GX3_INFO(_trans, _dev, GX3_freq, chksm_error, hdr_error, GX3_chksm) {}
static inline void pprz_msg_send_GX3_INFO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_GX3_freq, uint32_t *_chksm_error, uint32_t *_hdr_error, uint16_t *_GX3_chksm) {}
#define DOWNLINK_SEND_EXPLAIN(_trans, _dev, type, id, nb_string, string) {}
static inline void pprz_msg_send_EXPLAIN(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_type, uint8_t *_id, uint8_t nb_string, uint8_t *_string) {}
#define DOWNLINK_SEND_VIDEO_TELEMETRY(_trans, _dev, blob_x1, blob_y1, blob_x2, blob_y2, blob_x3, blob_y3, blob_x4, blob_y4) {}
static inline void pprz_msg_send_VIDEO_TELEMETRY(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_blob_x1, int32_t *_blob_y1, int32_t *_blob_x2, int32_t *_blob_y2, int32_t *_blob_x3, int32_t *_blob_y3, int32_t *_blob_x4, int32_t *_blob_y4) {}
#define DOWNLINK_SEND_VF_UPDATE(_trans, _dev, baro, range_meter) {}
static inline void pprz_msg_send_VF_UPDATE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_baro, float *_range_meter) {}
#define DOWNLINK_SEND_VF_PREDICT(_trans, _dev, accel) {}
static inline void pprz_msg_send_VF_PREDICT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_accel) {}
#define DOWNLINK_SEND_INV_FILTER(_trans, _dev, quat, phi_inv, theta_inv, psi_inv, Vx_inv, Vy_inv, Vz_inv, Px_inv, Py_inv, Pz_inv, bias_phi, bias_theta, bias_psi, bias_as, bias_hb, meas_baro, meas_gps) {}
static inline void pprz_msg_send_INV_FILTER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_quat, float *_phi_inv, float *_theta_inv, float *_psi_inv, float *_Vx_inv, float *_Vy_inv, float *_Vz_inv, float *_Px_inv, float *_Py_inv, float *_Pz_inv, float *_bias_phi, float *_bias_theta, float *_bias_psi, float *_bias_as, float *_bias_hb, float *_meas_baro, float *_meas_gps) {}
#define DOWNLINK_SEND_MISSION_STATUS(_trans, _dev, remaining_time, nb_task_list, task_list) {}
static inline void pprz_msg_send_MISSION_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_remaining_time, uint8_t nb_task_list, uint8_t *_task_list) {}
#define DOWNLINK_SEND_CROSS_TRACK_ERROR(_trans, _dev, cross_track_error, cte_int) {}
static inline void pprz_msg_send_CROSS_TRACK_ERROR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_cross_track_error, float *_cte_int) {}
#define DOWNLINK_SEND_GENERIC_COM(_trans, _dev, lat, lon, alt, gspeed, course, airspeed, vsupply, energy, throttle, ap_mode, nav_block, flight_time) {}
static inline void pprz_msg_send_GENERIC_COM(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_lat, int32_t *_lon, int16_t *_alt, uint16_t *_gspeed, int16_t *_course, uint16_t *_airspeed, uint8_t *_vsupply, uint8_t *_energy, uint8_t *_throttle, uint8_t *_ap_mode, uint8_t *_nav_block, uint16_t *_flight_time) {}
#define DOWNLINK_SEND_FORMATION_SLOT_TM(_trans, _dev, ac_id, mode, slot_east, slot_north, slot_alt) {}
static inline void pprz_msg_send_FORMATION_SLOT_TM(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id, uint8_t *_mode, float *_slot_east, float *_slot_north, float *_slot_alt) {}
#define DOWNLINK_SEND_FORMATION_STATUS_TM(_trans, _dev, ac_id, leader_id, status) {}
static inline void pprz_msg_send_FORMATION_STATUS_TM(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id, uint8_t *_leader_id, uint8_t *_status) {}
#define DOWNLINK_SEND_BMP_STATUS(_trans, _dev, UP, UT, press, temp) {}
static inline void pprz_msg_send_BMP_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_UP, int32_t *_UT, int32_t *_press, int32_t *_temp) {}
#define DOWNLINK_SEND_MLX_STATUS(_trans, _dev, itemp_case, temp_case, itemp_obj, temp_obj) {}
static inline void pprz_msg_send_MLX_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_itemp_case, float *_temp_case, uint16_t *_itemp_obj, float *_temp_obj) {}
#define DOWNLINK_SEND_TMP_STATUS(_trans, _dev, itemp, temp) {}
static inline void pprz_msg_send_TMP_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_itemp, float *_temp) {}
#define DOWNLINK_SEND_WIND_INFO_RET(_trans, _dev, east, north, airspeed) {}
static inline void pprz_msg_send_WIND_INFO_RET(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_east, float *_north, float *_airspeed) {}
#define DOWNLINK_SEND_SCP_STATUS(_trans, _dev, press, temp) {}
static inline void pprz_msg_send_SCP_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_press, int16_t *_temp) {}
#define DOWNLINK_SEND_SHT_STATUS(_trans, _dev, ihumid, itemp, humid, temp) {}
static inline void pprz_msg_send_SHT_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_ihumid, uint16_t *_itemp, float *_humid, float *_temp) {}
#define DOWNLINK_SEND_ENOSE_STATUS(_trans, _dev, val1, val2, val3, PID, nb_heat, heat) {}
static inline void pprz_msg_send_ENOSE_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_val1, uint16_t *_val2, uint16_t *_val3, uint16_t *_PID, uint8_t nb_heat, uint8_t *_heat) {}
#define DOWNLINK_SEND_DPICCO_STATUS(_trans, _dev, humid, temp, fhumid, ftemp) {}
static inline void pprz_msg_send_DPICCO_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_humid, uint16_t *_temp, float *_fhumid, float *_ftemp) {}
#define DOWNLINK_SEND_ANTENNA_DEBUG(_trans, _dev, mag_xraw, mag_yraw, mag_xcal, mag_ycal, mag_heading, mag_magnitude, mag_temp, mag_distor, mag_cal_status) {}
static inline void pprz_msg_send_ANTENNA_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_mag_xraw, int32_t *_mag_yraw, float *_mag_xcal, float *_mag_ycal, float *_mag_heading, float *_mag_magnitude, float *_mag_temp, uint8_t *_mag_distor, uint8_t *_mag_cal_status) {}
#define DOWNLINK_SEND_ANTENNA_STATUS(_trans, _dev, azim_sp, elev_sp, id_sp, mode) {}
static inline void pprz_msg_send_ANTENNA_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_azim_sp, float *_elev_sp, uint8_t *_id_sp, uint8_t *_mode) {}
#define DOWNLINK_SEND_MOTOR_BENCH_STATUS(_trans, _dev, time_ticks, throttle, rpm, current, thrust, torque, time_s, mode) {}
static inline void pprz_msg_send_MOTOR_BENCH_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_time_ticks, float *_throttle, float *_rpm, float *_current, float *_thrust, float *_torque, uint16_t *_time_s, uint8_t *_mode) {}
#define DOWNLINK_SEND_MOTOR_BENCH_STATIC(_trans, _dev, av_rpm, av_thrust, av_current, throttle) {}
static inline void pprz_msg_send_MOTOR_BENCH_STATIC(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_av_rpm, float *_av_thrust, float *_av_current, uint16_t *_throttle) {}
#define DOWNLINK_SEND_HIH_STATUS(_trans, _dev, humid, fhumid, ftemp) {}
static inline void pprz_msg_send_HIH_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_humid, float *_fhumid, float *_ftemp) {}
#define DOWNLINK_SEND_TEMT_STATUS(_trans, _dev, light, f_light) {}
static inline void pprz_msg_send_TEMT_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_light, float *_f_light) {}
#define DOWNLINK_SEND_GP2Y_STATUS(_trans, _dev, idensity, density) {}
static inline void pprz_msg_send_GP2Y_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_idensity, float *_density) {}
#define DOWNLINK_SEND_SHT_I2C_SERIAL(_trans, _dev, serial0, serial1) {}
static inline void pprz_msg_send_SHT_I2C_SERIAL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_serial0, uint32_t *_serial1) {}
#define DOWNLINK_SEND_PPM(_trans, _dev, ppm_rate, nb_values, values) {}
static inline void pprz_msg_send_PPM(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ppm_rate, uint8_t nb_values, uint16_t *_values) {}
#define DOWNLINK_SEND_RC(_trans, _dev, nb_values, values) {}
static inline void pprz_msg_send_RC(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_values, int16_t *_values) {}
#define DOWNLINK_SEND_COMMANDS(_trans, _dev, nb_values, values) {}
static inline void pprz_msg_send_COMMANDS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_values, int16_t *_values) {}
#define DOWNLINK_SEND_FBW_STATUS(_trans, _dev, rc_status, frame_rate, mode, vsupply, current) {}
static inline void pprz_msg_send_FBW_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_rc_status, uint8_t *_frame_rate, uint8_t *_mode, uint16_t *_vsupply, int32_t *_current) {}
#define DOWNLINK_SEND_ADC(_trans, _dev, mcu, nb_values, values) {}
static inline void pprz_msg_send_ADC(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_mcu, uint8_t nb_values, uint16_t *_values) {}
#define DOWNLINK_SEND_ACTUATORS(_trans, _dev, nb_values, values) {}
static inline void pprz_msg_send_ACTUATORS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_values, int16_t *_values) {}
#define DOWNLINK_SEND_BLUEGIGA(_trans, _dev, data_rate, nb_last_msg, last_msg) {}
static inline void pprz_msg_send_BLUEGIGA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_data_rate, uint8_t nb_last_msg, uint8_t *_last_msg) {}
#define DOWNLINK_SEND_MULTIGAZE_METERS(_trans, _dev, nb_multigaze_meters, multigaze_meters) {}
static inline void pprz_msg_send_MULTIGAZE_METERS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_multigaze_meters, float *_multigaze_meters) {}
#define DOWNLINK_SEND_DC_SHOT(_trans, _dev, photo_nr, lat, lon, alt, hmsl, phi, theta, psi, course, speed, itow) {}
static inline void pprz_msg_send_DC_SHOT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_photo_nr, int32_t *_lat, int32_t *_lon, int32_t *_alt, int32_t *_hmsl, int16_t *_phi, int16_t *_theta, int16_t *_psi, int16_t *_course, uint16_t *_speed, uint32_t *_itow) {}
#define DOWNLINK_SEND_TEST_BOARD_RESULTS(_trans, _dev, uart, ppm, nb_servo, servo) {}
static inline void pprz_msg_send_TEST_BOARD_RESULTS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_uart, uint8_t *_ppm, uint8_t nb_servo, uint16_t *_servo) {}
#define DOWNLINK_SEND_MLX_SERIAL(_trans, _dev, serial0, serial1) {}
static inline void pprz_msg_send_MLX_SERIAL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_serial0, uint32_t *_serial1) {}
#define DOWNLINK_SEND_PAYLOAD(_trans, _dev, nb_values, values) {}
static inline void pprz_msg_send_PAYLOAD(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_values, uint8_t *_values) {}
#define DOWNLINK_SEND_HTM_STATUS(_trans, _dev, ihumid, itemp, humid, temp) {}
static inline void pprz_msg_send_HTM_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_ihumid, uint16_t *_itemp, float *_humid, float *_temp) {}
#define DOWNLINK_SEND_BARO_MS5611(_trans, _dev, d1, d2, pressure, temp) {}
static inline void pprz_msg_send_BARO_MS5611(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_d1, uint32_t *_d2, float *_pressure, float *_temp) {}
#define DOWNLINK_SEND_MS5611_COEFF(_trans, _dev, c0, c1, c2, c3, c4, c5, c6, c7) {}
static inline void pprz_msg_send_MS5611_COEFF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_c0, uint16_t *_c1, uint16_t *_c2, uint16_t *_c3, uint16_t *_c4, uint16_t *_c5, uint16_t *_c6, uint16_t *_c7) {}
#define DOWNLINK_SEND_ATMOSPHERE_CHARGE(_trans, _dev, t0, t1, t2, t3, t4, t5, t6, t7, t8, t9) {}
static inline void pprz_msg_send_ATMOSPHERE_CHARGE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_t0, uint16_t *_t1, uint16_t *_t2, uint16_t *_t3, uint16_t *_t4, uint16_t *_t5, uint16_t *_t6, uint16_t *_t7, uint16_t *_t8, uint16_t *_t9) {}
#define DOWNLINK_SEND_SOLAR_RADIATION(_trans, _dev, up_t0, dn_t0, up_t1, dn_t1, up_t2, dn_t2, up_t3, dn_t3, up_t4, dn_t4, up_t5, dn_t5, up_t6, dn_t6, up_t7, dn_t7, up_t8, dn_t8, up_t9, dn_t9) {}
static inline void pprz_msg_send_SOLAR_RADIATION(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_up_t0, uint16_t *_dn_t0, uint16_t *_up_t1, uint16_t *_dn_t1, uint16_t *_up_t2, uint16_t *_dn_t2, uint16_t *_up_t3, uint16_t *_dn_t3, uint16_t *_up_t4, uint16_t *_dn_t4, uint16_t *_up_t5, uint16_t *_dn_t5, uint16_t *_up_t6, uint16_t *_dn_t6, uint16_t *_up_t7, uint16_t *_dn_t7, uint16_t *_up_t8, uint16_t *_dn_t8, uint16_t *_up_t9, uint16_t *_dn_t9) {}
#define DOWNLINK_SEND_TCAS_TA(_trans, _dev, ac_id) {}
static inline void pprz_msg_send_TCAS_TA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id) {}
#define DOWNLINK_SEND_TCAS_RA(_trans, _dev, ac_id, resolve) {}
static inline void pprz_msg_send_TCAS_RA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id, uint8_t *_resolve) {}
#define DOWNLINK_SEND_TCAS_RESOLVED(_trans, _dev, ac_id) {}
static inline void pprz_msg_send_TCAS_RESOLVED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id) {}
#define DOWNLINK_SEND_TCAS_DEBUG(_trans, _dev, ac_id, tau) {}
static inline void pprz_msg_send_TCAS_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_ac_id, float *_tau) {}
#define DOWNLINK_SEND_POTENTIAL(_trans, _dev, east, north, alt, speed, climb) {}
static inline void pprz_msg_send_POTENTIAL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_east, float *_north, float *_alt, float *_speed, float *_climb) {}
#define DOWNLINK_SEND_VERTICAL_ENERGY(_trans, _dev, Epot_err, Ekin_err, Etot_err, Edis_err, throttle, nav_pitch, speed_sp) {}
static inline void pprz_msg_send_VERTICAL_ENERGY(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_Epot_err, float *_Ekin_err, float *_Etot_err, float *_Edis_err, float *_throttle, float *_nav_pitch, float *_speed_sp) {}
#define DOWNLINK_SEND_TEMP_TCOUPLE(_trans, _dev, fval0, fval1, fval2, fval3, fref0, fref1, fref2, fref3, val0, val1, val2, val3, ref0, ref1, ref2, ref3) {}
static inline void pprz_msg_send_TEMP_TCOUPLE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_fval0, float *_fval1, float *_fval2, float *_fval3, float *_fref0, float *_fref1, float *_fref2, float *_fref3, uint16_t *_val0, uint16_t *_val1, uint16_t *_val2, uint16_t *_val3, uint16_t *_ref0, uint16_t *_ref1, uint16_t *_ref2, uint16_t *_ref3) {}
#define DOWNLINK_SEND_SHT_I2C_STATUS(_trans, _dev, ihumid, itemp, humid, temp) {}
static inline void pprz_msg_send_SHT_I2C_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_ihumid, uint16_t *_itemp, float *_humid, float *_temp) {}
#define DOWNLINK_SEND_CAMERA_SNAPSHOT(_trans, _dev, snapshot_image_number) {}
static inline void pprz_msg_send_CAMERA_SNAPSHOT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_snapshot_image_number) {}
#define DOWNLINK_SEND_TIMESTAMP(_trans, _dev, timestamp) {}
static inline void pprz_msg_send_TIMESTAMP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_timestamp) {}
#define DOWNLINK_SEND_STAB_ATTITUDE_FLOAT(_trans, _dev, est_p, est_q, est_r, est_phi, est_theta, est_psi, ref_phi, ref_theta, ref_psi, sum_err_phi, sum_err_theta, sum_err_psi, delta_a_fb, delta_e_fb, delta_r_fb, delta_a_ff, delta_e_ff, delta_r_ff, delta_a, delta_e, delta_r, est_p_d, est_q_d, est_r_d) {}
static inline void pprz_msg_send_STAB_ATTITUDE_FLOAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_est_p, float *_est_q, float *_est_r, float *_est_phi, float *_est_theta, float *_est_psi, float *_ref_phi, float *_ref_theta, float *_ref_psi, float *_sum_err_phi, float *_sum_err_theta, float *_sum_err_psi, float *_delta_a_fb, float *_delta_e_fb, float *_delta_r_fb, float *_delta_a_ff, float *_delta_e_ff, float *_delta_r_ff, int32_t *_delta_a, int32_t *_delta_e, int32_t *_delta_r, float *_est_p_d, float *_est_q_d, float *_est_r_d) {}
#define DOWNLINK_SEND_IMU_GYRO_SCALED(_trans, _dev, gp, gq, gr) {}
static inline void pprz_msg_send_IMU_GYRO_SCALED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_gp, int32_t *_gq, int32_t *_gr) {}
#define DOWNLINK_SEND_IMU_ACCEL_SCALED(_trans, _dev, ax, ay, az) {}
static inline void pprz_msg_send_IMU_ACCEL_SCALED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_ax, int32_t *_ay, int32_t *_az) {}
#define DOWNLINK_SEND_IMU_MAG_SCALED(_trans, _dev, mx, my, mz) {}
static inline void pprz_msg_send_IMU_MAG_SCALED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_mx, int32_t *_my, int32_t *_mz) {}
#define DOWNLINK_SEND_FILTER(_trans, _dev, phi, theta, psi, measure_phi, measure_theta, measure_psi, corrected_phi, corrected_theta, corrected_psi, correction_phi, correction_theta, correction_psi, bp, bq, br, comp_id) {}
static inline void pprz_msg_send_FILTER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_phi, int32_t *_theta, int32_t *_psi, int32_t *_measure_phi, int32_t *_measure_theta, int32_t *_measure_psi, int32_t *_corrected_phi, int32_t *_corrected_theta, int32_t *_corrected_psi, int32_t *_correction_phi, int32_t *_correction_theta, int32_t *_correction_psi, int32_t *_bp, int32_t *_bq, int32_t *_br, uint8_t *_comp_id) {}
#define DOWNLINK_SEND_FILTER2(_trans, _dev, px, py, pz, gsx, gsy, gsz) {}
static inline void pprz_msg_send_FILTER2(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_px, int32_t *_py, int32_t *_pz, int32_t *_gsx, int32_t *_gsy, int32_t *_gsz) {}
#define DOWNLINK_SEND_RATE_LOOP(_trans, _dev, sp_p, sp_q, sp_r, sumerr_p, sumerr_q, sumerr_r, fb_p, fb_q, fb_r, delta_t) {}
static inline void pprz_msg_send_RATE_LOOP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_sp_p, int32_t *_sp_q, int32_t *_sp_r, int32_t *_sumerr_p, int32_t *_sumerr_q, int32_t *_sumerr_r, int32_t *_fb_p, int32_t *_fb_q, int32_t *_fb_r, int32_t *_delta_t) {}
#define DOWNLINK_SEND_FILTER_ALIGNER(_trans, _dev, lp_gp, lp_gq, lp_gr, gp, gq, gr, noise, cnt, status) {}
static inline void pprz_msg_send_FILTER_ALIGNER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_lp_gp, int32_t *_lp_gq, int32_t *_lp_gr, int32_t *_gp, int32_t *_gq, int32_t *_gr, int32_t *_noise, int32_t *_cnt, uint8_t *_status) {}
#define DOWNLINK_SEND_AIRSPEED_MS45XX(_trans, _dev, diffPress, temperature, airspeed) {}
static inline void pprz_msg_send_AIRSPEED_MS45XX(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_diffPress, int16_t *_temperature, float *_airspeed) {}
#define DOWNLINK_SEND_FILTER_COR(_trans, _dev, mphi, mtheta, mpsi, qi, qx, qy, qz) {}
static inline void pprz_msg_send_FILTER_COR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_mphi, int32_t *_mtheta, int32_t *_mpsi, int32_t *_qi, int32_t *_qx, int32_t *_qy, int32_t *_qz) {}
#define DOWNLINK_SEND_STAB_ATTITUDE_INT(_trans, _dev, est_p, est_q, est_r, est_phi, est_theta, est_psi, sp_phi, sp_theta, sp_psi, sum_err_phi, sum_err_theta, sum_err_psi, delta_a_fb, delta_e_fb, delta_r_fb, delta_a_ff, delta_e_ff, delta_r_ff, delta_a, delta_e, delta_r) {}
static inline void pprz_msg_send_STAB_ATTITUDE_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_est_p, int32_t *_est_q, int32_t *_est_r, int32_t *_est_phi, int32_t *_est_theta, int32_t *_est_psi, int32_t *_sp_phi, int32_t *_sp_theta, int32_t *_sp_psi, int32_t *_sum_err_phi, int32_t *_sum_err_theta, int32_t *_sum_err_psi, int32_t *_delta_a_fb, int32_t *_delta_e_fb, int32_t *_delta_r_fb, int32_t *_delta_a_ff, int32_t *_delta_e_ff, int32_t *_delta_r_ff, int32_t *_delta_a, int32_t *_delta_e, int32_t *_delta_r) {}
#define DOWNLINK_SEND_STAB_ATTITUDE_REF_INT(_trans, _dev, sp_phi, sp_theta, sp_psi, ref_phi, ref_theta, ref_psi, ref_p, ref_q, ref_r, ref_pd, ref_qd, ref_rd) {}
static inline void pprz_msg_send_STAB_ATTITUDE_REF_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_sp_phi, int32_t *_sp_theta, int32_t *_sp_psi, int32_t *_ref_phi, int32_t *_ref_theta, int32_t *_ref_psi, int32_t *_ref_p, int32_t *_ref_q, int32_t *_ref_r, int32_t *_ref_pd, int32_t *_ref_qd, int32_t *_ref_rd) {}
#define DOWNLINK_SEND_STAB_ATTITUDE_REF_FLOAT(_trans, _dev, sp_phi, sp_theta, sp_psi, ref_phi, ref_theta, ref_psi, ref_p, ref_q, ref_r, ref_pd, ref_qd, ref_rd) {}
static inline void pprz_msg_send_STAB_ATTITUDE_REF_FLOAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_sp_phi, float *_sp_theta, float *_sp_psi, float *_ref_phi, float *_ref_theta, float *_ref_psi, float *_ref_p, float *_ref_q, float *_ref_r, float *_ref_pd, float *_ref_qd, float *_ref_rd) {}
#define DOWNLINK_SEND_ROTORCRAFT_CMD(_trans, _dev, cmd_roll, cmd_pitch, cmd_yaw, cmd_thrust) {}
static inline void pprz_msg_send_ROTORCRAFT_CMD(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_cmd_roll, int32_t *_cmd_pitch, int32_t *_cmd_yaw, int32_t *_cmd_thrust) {}
#define DOWNLINK_SEND_GUIDANCE_H_INT(_trans, _dev, sp_x, sp_y, ref_x, ref_y, est_x, est_y) {}
static inline void pprz_msg_send_GUIDANCE_H_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_sp_x, int32_t *_sp_y, int32_t *_ref_x, int32_t *_ref_y, int32_t *_est_x, int32_t *_est_y) {}
#define DOWNLINK_SEND_VERT_LOOP(_trans, _dev, z_sp, zd_sp, est_z, est_zd, est_zdd, ref_z, ref_zd, ref_zdd, adp_inv_m, adp_cov, adp_meas, sum_err, ff_cmd, fb_cmd, delta_t) {}
static inline void pprz_msg_send_VERT_LOOP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_z_sp, int32_t *_zd_sp, int32_t *_est_z, int32_t *_est_zd, int32_t *_est_zdd, int32_t *_ref_z, int32_t *_ref_zd, int32_t *_ref_zdd, int32_t *_adp_inv_m, int32_t *_adp_cov, int32_t *_adp_meas, int32_t *_sum_err, int32_t *_ff_cmd, int32_t *_fb_cmd, int32_t *_delta_t) {}
#define DOWNLINK_SEND_HOVER_LOOP(_trans, _dev, sp_x, sp_y, est_x, est_y, est_xd, est_yd, est_xdd, est_ydd, err_x, err_y, err_xd, err_yd, err_sum_x, err_sum_y, cmd_x, cmd_y, cmd_heading) {}
static inline void pprz_msg_send_HOVER_LOOP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_sp_x, int32_t *_sp_y, int32_t *_est_x, int32_t *_est_y, int32_t *_est_xd, int32_t *_est_yd, int32_t *_est_xdd, int32_t *_est_ydd, int32_t *_err_x, int32_t *_err_y, int32_t *_err_xd, int32_t *_err_yd, int32_t *_err_sum_x, int32_t *_err_sum_y, int32_t *_cmd_x, int32_t *_cmd_y, int32_t *_cmd_heading) {}
#define DOWNLINK_SEND_ROTORCRAFT_FP(_trans, _dev, east, north, up, veast, vnorth, vup, phi, theta, psi, carrot_east, carrot_north, carrot_up, carrot_psi, thrust, flight_time) {}
static inline void pprz_msg_send_ROTORCRAFT_FP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_east, int32_t *_north, int32_t *_up, int32_t *_veast, int32_t *_vnorth, int32_t *_vup, int32_t *_phi, int32_t *_theta, int32_t *_psi, int32_t *_carrot_east, int32_t *_carrot_north, int32_t *_carrot_up, int32_t *_carrot_psi, int32_t *_thrust, uint16_t *_flight_time) {}
#define DOWNLINK_SEND_TEMP_ADC(_trans, _dev, temp1, temp2, temp3) {}
static inline void pprz_msg_send_TEMP_ADC(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_temp1, float *_temp2, float *_temp3) {}
#define DOWNLINK_SEND_GUIDANCE_H_REF_INT(_trans, _dev, sp_x, ref_x, sp_xd, ref_xd, ref_xdd, sp_y, ref_y, sp_yd, ref_yd, ref_ydd) {}
static inline void pprz_msg_send_GUIDANCE_H_REF_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_sp_x, int32_t *_ref_x, int32_t *_sp_xd, int32_t *_ref_xd, int32_t *_ref_xdd, int32_t *_sp_y, int32_t *_ref_y, int32_t *_sp_yd, int32_t *_ref_yd, int32_t *_ref_ydd) {}
#define DOWNLINK_SEND_ROTORCRAFT_TUNE_HOVER(_trans, _dev, rc_roll, rc_pitch, rc_yaw, cmd_roll, cmd_pitch, cmd_yaw, cmd_thrust, body_phi, body_theta, body_psi) {}
static inline void pprz_msg_send_ROTORCRAFT_TUNE_HOVER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_rc_roll, int16_t *_rc_pitch, int16_t *_rc_yaw, int32_t *_cmd_roll, int32_t *_cmd_pitch, int32_t *_cmd_yaw, int32_t *_cmd_thrust, int32_t *_body_phi, int32_t *_body_theta, int32_t *_body_psi) {}
#define DOWNLINK_SEND_INS_Z(_trans, _dev, baro_z, ins_z, ins_zd, ins_zdd) {}
static inline void pprz_msg_send_INS_Z(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_baro_z, int32_t *_ins_z, int32_t *_ins_zd, int32_t *_ins_zdd) {}
#define DOWNLINK_SEND_PCAP01_STATUS(_trans, _dev, ihumid, itemp, humid, temp) {}
static inline void pprz_msg_send_PCAP01_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_ihumid, uint32_t *_itemp, float *_humid, float *_temp) {}
#define DOWNLINK_SEND_GEIGER_COUNTER(_trans, _dev, tube1, tube2, vsupply) {}
static inline void pprz_msg_send_GEIGER_COUNTER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_tube1, uint32_t *_tube2, uint16_t *_vsupply) {}
#define DOWNLINK_SEND_INS_REF(_trans, _dev, ecef_x0, ecef_y0, ecef_z0, lat0, lon0, alt0, hmsl0, baro_qfe) {}
static inline void pprz_msg_send_INS_REF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_ecef_x0, int32_t *_ecef_y0, int32_t *_ecef_z0, int32_t *_lat0, int32_t *_lon0, int32_t *_alt0, int32_t *_hmsl0, float *_baro_qfe) {}
#define DOWNLINK_SEND_GPS_INT(_trans, _dev, ecef_x, ecef_y, ecef_z, lat, lon, alt, hmsl, ecef_xd, ecef_yd, ecef_zd, pacc, sacc, tow, pdop, numsv, fix) {}
static inline void pprz_msg_send_GPS_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_ecef_x, int32_t *_ecef_y, int32_t *_ecef_z, int32_t *_lat, int32_t *_lon, int32_t *_alt, int32_t *_hmsl, int32_t *_ecef_xd, int32_t *_ecef_yd, int32_t *_ecef_zd, uint32_t *_pacc, uint32_t *_sacc, uint32_t *_tow, uint16_t *_pdop, uint8_t *_numsv, uint8_t *_fix) {}
#define DOWNLINK_SEND_AHRS_EULER_INT(_trans, _dev, imu_phi, imu_theta, imu_psi, body_phi, body_theta, body_psi, comp_id) {}
static inline void pprz_msg_send_AHRS_EULER_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_imu_phi, int32_t *_imu_theta, int32_t *_imu_psi, int32_t *_body_phi, int32_t *_body_theta, int32_t *_body_psi, uint8_t *_comp_id) {}
#define DOWNLINK_SEND_AHRS_QUAT_INT(_trans, _dev, weight, imu_qi, imu_qx, imu_qy, imu_qz, body_qi, body_qx, body_qy, body_qz, comp_id) {}
static inline void pprz_msg_send_AHRS_QUAT_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_weight, int32_t *_imu_qi, int32_t *_imu_qx, int32_t *_imu_qy, int32_t *_imu_qz, int32_t *_body_qi, int32_t *_body_qx, int32_t *_body_qy, int32_t *_body_qz, uint8_t *_comp_id) {}
#define DOWNLINK_SEND_AHRS_RMAT_INT(_trans, _dev, imu_m00, imu_m01, imu_m02, imu_m10, imu_m11, imu_m12, imu_m20, imu_m21, imu_m22, body_m00, body_m01, body_m02, body_m10, body_m11, body_m12, body_m20, body_m21, body_m22, comp_id) {}
static inline void pprz_msg_send_AHRS_RMAT_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_imu_m00, int32_t *_imu_m01, int32_t *_imu_m02, int32_t *_imu_m10, int32_t *_imu_m11, int32_t *_imu_m12, int32_t *_imu_m20, int32_t *_imu_m21, int32_t *_imu_m22, int32_t *_body_m00, int32_t *_body_m01, int32_t *_body_m02, int32_t *_body_m10, int32_t *_body_m11, int32_t *_body_m12, int32_t *_body_m20, int32_t *_body_m21, int32_t *_body_m22, uint8_t *_comp_id) {}
#define DOWNLINK_SEND_ROTORCRAFT_NAV_STATUS(_trans, _dev, block_time, stage_time, dist_home, dist_wp, cur_block, cur_stage, horizontal_mode) {}
static inline void pprz_msg_send_ROTORCRAFT_NAV_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_block_time, uint16_t *_stage_time, float *_dist_home, float *_dist_wp, uint8_t *_cur_block, uint8_t *_cur_stage, uint8_t *_horizontal_mode) {}
#define DOWNLINK_SEND_ROTORCRAFT_RADIO_CONTROL(_trans, _dev, roll, pitch, yaw, throttle, mode, kill, status) {}
static inline void pprz_msg_send_ROTORCRAFT_RADIO_CONTROL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_roll, int16_t *_pitch, int16_t *_yaw, int16_t *_throttle, int16_t *_mode, int16_t *_kill, uint8_t *_status) {}
#define DOWNLINK_SEND_VFF_EXTENDED(_trans, _dev, meas_baro, meas_alt, z, zd, zdd, bias, offset) {}
static inline void pprz_msg_send_VFF_EXTENDED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_meas_baro, float *_meas_alt, float *_z, float *_zd, float *_zdd, float *_bias, float *_offset) {}
#define DOWNLINK_SEND_VFF(_trans, _dev, measure, z, zd, bias, Pzz, Pzdzd, Pbb) {}
static inline void pprz_msg_send_VFF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_measure, float *_z, float *_zd, float *_bias, float *_Pzz, float *_Pzdzd, float *_Pbb) {}
#define DOWNLINK_SEND_GEO_MAG(_trans, _dev, Hx, Hy, Hz, comp_id) {}
static inline void pprz_msg_send_GEO_MAG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_Hx, float *_Hy, float *_Hz, uint8_t *_comp_id) {}
#define DOWNLINK_SEND_HFF(_trans, _dev, x, y, xd, yd, xdd, ydd) {}
static inline void pprz_msg_send_HFF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_x, float *_y, float *_xd, float *_yd, float *_xdd, float *_ydd) {}
#define DOWNLINK_SEND_HFF_DBG(_trans, _dev, x_measure, y_measure, xd_measure, yd_measure, Pxx, Pyy, Pxdxd, Pydyd) {}
static inline void pprz_msg_send_HFF_DBG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_x_measure, float *_y_measure, float *_xd_measure, float *_yd_measure, float *_Pxx, float *_Pyy, float *_Pxdxd, float *_Pydyd) {}
#define DOWNLINK_SEND_HFF_GPS(_trans, _dev, lag_cnt, lag_cnt_err, save_cnt) {}
static inline void pprz_msg_send_HFF_GPS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_lag_cnt, int16_t *_lag_cnt_err, int16_t *_save_cnt) {}
#define DOWNLINK_SEND_INS_SONAR(_trans, _dev, distance, var) {}
static inline void pprz_msg_send_INS_SONAR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_distance, float *_var) {}
#define DOWNLINK_SEND_ROTORCRAFT_CAM(_trans, _dev, tilt, pan) {}
static inline void pprz_msg_send_ROTORCRAFT_CAM(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_tilt, int16_t *_pan) {}
#define DOWNLINK_SEND_AHRS_REF_QUAT(_trans, _dev, ref_qi, ref_qx, ref_qy, ref_qz, body_qi, body_qx, body_qy, body_qz) {}
static inline void pprz_msg_send_AHRS_REF_QUAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_ref_qi, int32_t *_ref_qx, int32_t *_ref_qy, int32_t *_ref_qz, int32_t *_body_qi, int32_t *_body_qx, int32_t *_body_qy, int32_t *_body_qz) {}
#define DOWNLINK_SEND_EKF7_XHAT(_trans, _dev, c, s1, s2, s3, p, q, r, bp, bq, br) {}
static inline void pprz_msg_send_EKF7_XHAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_c, float *_s1, float *_s2, float *_s3, float *_p, float *_q, float *_r, float *_bp, float *_bq, float *_br) {}
#define DOWNLINK_SEND_EKF7_Y(_trans, _dev, timecount, g1, g2, g3, m1, m2, m3, p, q, r) {}
static inline void pprz_msg_send_EKF7_Y(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_timecount, float *_g1, float *_g2, float *_g3, float *_m1, float *_m2, float *_m3, float *_p, float *_q, float *_r) {}
#define DOWNLINK_SEND_EKF7_P_DIAG(_trans, _dev, c, s1, s2, s3, p, q, r, bp, bq, br) {}
static inline void pprz_msg_send_EKF7_P_DIAG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_c, float *_s1, float *_s2, float *_s3, float *_p, float *_q, float *_r, float *_bp, float *_bq, float *_br) {}
#define DOWNLINK_SEND_AHRS_EULER(_trans, _dev, phi, theta, psi, comp_id) {}
static inline void pprz_msg_send_AHRS_EULER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_phi, float *_theta, float *_psi, uint8_t *_comp_id) {}
#define DOWNLINK_SEND_AHRS_MEASUREMENT_EULER(_trans, _dev, phi, theta, psi) {}
static inline void pprz_msg_send_AHRS_MEASUREMENT_EULER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_phi, float *_theta, float *_psi) {}
#define DOWNLINK_SEND_WT(_trans, _dev, rpm) {}
static inline void pprz_msg_send_WT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_rpm) {}
#define DOWNLINK_SEND_CSC_CAN_DEBUG(_trans, _dev, err_nb, err_code) {}
static inline void pprz_msg_send_CSC_CAN_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_err_nb, uint32_t *_err_code) {}
#define DOWNLINK_SEND_CSC_CAN_MSG(_trans, _dev, frame, id, data_a, data_b) {}
static inline void pprz_msg_send_CSC_CAN_MSG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_frame, uint32_t *_id, uint32_t *_data_a, uint32_t *_data_b) {}
#define DOWNLINK_SEND_AHRS_GYRO_BIAS_INT(_trans, _dev, bp, bq, br, comp_id) {}
static inline void pprz_msg_send_AHRS_GYRO_BIAS_INT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_bp, int32_t *_bq, int32_t *_br, uint8_t *_comp_id) {}
#define DOWNLINK_SEND_FLOW_AP_OTF(_trans, _dev, counter, velocity, a_attack, a_sidesl, altitude, checksum) {}
static inline void pprz_msg_send_FLOW_AP_OTF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_counter, int16_t *_velocity, int16_t *_a_attack, int16_t *_a_sidesl, int32_t *_altitude, uint8_t *_checksum) {}
#define DOWNLINK_SEND_FMS_TIME(_trans, _dev, tv_sec, tv_nsec, delay_ns) {}
static inline void pprz_msg_send_FMS_TIME(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_tv_sec, uint32_t *_tv_nsec, uint32_t *_delay_ns) {}
#define DOWNLINK_SEND_LOADCELL(_trans, _dev, load) {}
static inline void pprz_msg_send_LOADCELL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_load) {}
#define DOWNLINK_SEND_FLA_DEBUG(_trans, _dev, past_input, imu_rate, desired_accel, motor_command) {}
static inline void pprz_msg_send_FLA_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_past_input, float *_imu_rate, float *_desired_accel, float *_motor_command) {}
#define DOWNLINK_SEND_BLMC_FAULT_STATUS(_trans, _dev, nb_raw_fault, raw_fault) {}
static inline void pprz_msg_send_BLMC_FAULT_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_raw_fault, uint16_t *_raw_fault) {}
#define DOWNLINK_SEND_BLMC_SPEEDS(_trans, _dev, nb_speeds, speeds) {}
static inline void pprz_msg_send_BLMC_SPEEDS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_speeds, int16_t *_speeds) {}
#define DOWNLINK_SEND_AHRS_DEBUG_QUAT(_trans, _dev, jqi, jqx, jqy, jqz, xqi, xqx, xqy, xqz, mqi, mqx, mqy, mqz) {}
static inline void pprz_msg_send_AHRS_DEBUG_QUAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_jqi, float *_jqx, float *_jqy, float *_jqz, float *_xqi, float *_xqx, float *_xqy, float *_xqz, float *_mqi, float *_mqx, float *_mqy, float *_mqz) {}
#define DOWNLINK_SEND_BLMC_BUSVOLTS(_trans, _dev, nb_busvolts, busvolts) {}
static inline void pprz_msg_send_BLMC_BUSVOLTS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_busvolts, uint16_t *_busvolts) {}
#define DOWNLINK_SEND_SYSTEM_STATUS(_trans, _dev, csc1_loop_count, csc1_msg_count, csc2_loop_count, csc2_msg_count, can_rx_err, can_tx_err, rc_parser_err, system_fault) {}
static inline void pprz_msg_send_SYSTEM_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_csc1_loop_count, uint32_t *_csc1_msg_count, uint32_t *_csc2_loop_count, uint32_t *_csc2_msg_count, uint32_t *_can_rx_err, uint32_t *_can_tx_err, uint32_t *_rc_parser_err, uint8_t *_system_fault) {}
#define DOWNLINK_SEND_DYNAMIXEL(_trans, _dev, left_wing, right_wing, left_wing_flag, right_wing_flag, invalid_position, timeout_events, checksum_errors, fuse_rotation_angle, fuse_rotation_rate) {}
static inline void pprz_msg_send_DYNAMIXEL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_left_wing, uint16_t *_right_wing, uint8_t *_left_wing_flag, uint8_t *_right_wing_flag, uint32_t *_invalid_position, uint32_t *_timeout_events, uint32_t *_checksum_errors, float *_fuse_rotation_angle, float *_fuse_rotation_rate) {}
#define DOWNLINK_SEND_RMAT_DEBUG(_trans, _dev, a, b, c, d, e, f, g, h, i) {}
static inline void pprz_msg_send_RMAT_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_a, float *_b, float *_c, float *_d, float *_e, float *_f, float *_g, float *_h, float *_i) {}
#define DOWNLINK_SEND_SIMPLE_COMMANDS(_trans, _dev, roll, pitch, yaw) {}
static inline void pprz_msg_send_SIMPLE_COMMANDS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int16_t *_roll, int16_t *_pitch, int16_t *_yaw) {}
#define DOWNLINK_SEND_VANE_SENSOR(_trans, _dev, alpha, alpha_filtered, alpha_target, alpha_vane_error, alpha2, beta, beta_filtered, beta_target, beta_vane_error, beta2) {}
static inline void pprz_msg_send_VANE_SENSOR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_alpha, float *_alpha_filtered, float *_alpha_target, float *_alpha_vane_error, float *_alpha2, float *_beta, float *_beta_filtered, float *_beta_target, float *_beta_vane_error, float *_beta2) {}
#define DOWNLINK_SEND_CONTROLLER_GAINS(_trans, _dev, roll_gamma_p, roll_gamma_d, roll_gamma_i, pitch_gamma_p, pitch_gamma_d, pitch_gamma_i, yaw_gamma_p, yaw_gamma_d, yaw_gamma_i) {}
static inline void pprz_msg_send_CONTROLLER_GAINS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_roll_gamma_p, float *_roll_gamma_d, float *_roll_gamma_i, float *_pitch_gamma_p, float *_pitch_gamma_d, float *_pitch_gamma_i, float *_yaw_gamma_p, float *_yaw_gamma_d, float *_yaw_gamma_i) {}
#define DOWNLINK_SEND_AHRS_LKF(_trans, _dev, phi, theta, psi, qi, qx, qy, qz, p, q, r, ax, ay, az, mx, my, mz) {}
static inline void pprz_msg_send_AHRS_LKF(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_phi, float *_theta, float *_psi, float *_qi, float *_qx, float *_qy, float *_qz, float *_p, float *_q, float *_r, float *_ax, float *_ay, float *_az, float *_mx, float *_my, float *_mz) {}
#define DOWNLINK_SEND_AHRS_LKF_DEBUG(_trans, _dev, phi_err, theta_err, psi_err, bp, bq, br, quat_norm, phi_accel, theta_accel, phi_cov, theta_cov, psi_cov, bp_cov, bq_cov, br_cov) {}
static inline void pprz_msg_send_AHRS_LKF_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_phi_err, float *_theta_err, float *_psi_err, float *_bp, float *_bq, float *_br, float *_quat_norm, float *_phi_accel, float *_theta_accel, float *_phi_cov, float *_theta_cov, float *_psi_cov, float *_bp_cov, float *_bq_cov, float *_br_cov) {}
#define DOWNLINK_SEND_AHRS_LKF_ACC_DBG(_trans, _dev, qi_err, qx_err, qy_err, qz_err, bp_err, bq_err, br_err) {}
static inline void pprz_msg_send_AHRS_LKF_ACC_DBG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_qi_err, float *_qx_err, float *_qy_err, float *_qz_err, float *_bp_err, float *_bq_err, float *_br_err) {}
#define DOWNLINK_SEND_AHRS_LKF_MAG_DBG(_trans, _dev, qi_err, qx_err, qy_err, qz_err, bp_err, bq_err, br_err) {}
static inline void pprz_msg_send_AHRS_LKF_MAG_DBG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_qi_err, float *_qx_err, float *_qy_err, float *_qz_err, float *_bp_err, float *_bq_err, float *_br_err) {}
#define DOWNLINK_SEND_NPS_SENSORS_SCALED(_trans, _dev, acc_x, acc_y, acc_z, mag_x, mag_y, mag_z) {}
static inline void pprz_msg_send_NPS_SENSORS_SCALED(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_acc_x, float *_acc_y, float *_acc_z, float *_mag_x, float *_mag_y, float *_mag_z) {}
#define DOWNLINK_SEND_INS(_trans, _dev, ins_x, ins_y, ins_z, ins_xd, ins_yd, ins_zd, ins_xdd, ins_ydd, ins_zdd) {}
static inline void pprz_msg_send_INS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_ins_x, int32_t *_ins_y, int32_t *_ins_z, int32_t *_ins_xd, int32_t *_ins_yd, int32_t *_ins_zd, int32_t *_ins_xdd, int32_t *_ins_ydd, int32_t *_ins_zdd) {}
#define DOWNLINK_SEND_GPS_ERROR(_trans, _dev, x_position, y_position, z_position, x_velocity, y_velocity, z_velocity) {}
static inline void pprz_msg_send_GPS_ERROR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_x_position, float *_y_position, float *_z_position, float *_x_velocity, float *_y_velocity, float *_z_velocity) {}
#define DOWNLINK_SEND_IMU_GYRO(_trans, _dev, gp, gq, gr) {}
static inline void pprz_msg_send_IMU_GYRO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_gp, float *_gq, float *_gr) {}
#define DOWNLINK_SEND_IMU_MAG(_trans, _dev, mx, my, mz) {}
static inline void pprz_msg_send_IMU_MAG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_mx, float *_my, float *_mz) {}
#define DOWNLINK_SEND_IMU_ACCEL(_trans, _dev, ax, ay, az) {}
static inline void pprz_msg_send_IMU_ACCEL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_ax, float *_ay, float *_az) {}
#define DOWNLINK_SEND_IMU_GYRO_RAW(_trans, _dev, gp, gq, gr) {}
static inline void pprz_msg_send_IMU_GYRO_RAW(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_gp, int32_t *_gq, int32_t *_gr) {}
#define DOWNLINK_SEND_IMU_ACCEL_RAW(_trans, _dev, ax, ay, az) {}
static inline void pprz_msg_send_IMU_ACCEL_RAW(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_ax, int32_t *_ay, int32_t *_az) {}
#define DOWNLINK_SEND_IMU_MAG_RAW(_trans, _dev, mx, my, mz) {}
static inline void pprz_msg_send_IMU_MAG_RAW(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_mx, int32_t *_my, int32_t *_mz) {}
#define DOWNLINK_SEND_IMU_MAG_SETTINGS(_trans, _dev, inclination, declination, hardiron_x, hardiron_y, hardiron_z) {}
static inline void pprz_msg_send_IMU_MAG_SETTINGS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_inclination, float *_declination, float *_hardiron_x, float *_hardiron_y, float *_hardiron_z) {}
#define DOWNLINK_SEND_IMU_MAG_CURRENT_CALIBRATION(_trans, _dev, mx, my, mz, electrical_current) {}
static inline void pprz_msg_send_IMU_MAG_CURRENT_CALIBRATION(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_mx, int32_t *_my, int32_t *_mz, int32_t *_electrical_current) {}
#define DOWNLINK_SEND_UART_ERRORS(_trans, _dev, overrun_cnt, noise_err_cnt, framing_err_cnt, bus_number) {}
static inline void pprz_msg_send_UART_ERRORS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_overrun_cnt, uint16_t *_noise_err_cnt, uint16_t *_framing_err_cnt, uint8_t *_bus_number) {}
#define DOWNLINK_SEND_IMU_GYRO_LP(_trans, _dev, gp, gq, gr) {}
static inline void pprz_msg_send_IMU_GYRO_LP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_gp, float *_gq, float *_gr) {}
#define DOWNLINK_SEND_IMU_PRESSURE(_trans, _dev, p) {}
static inline void pprz_msg_send_IMU_PRESSURE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_p) {}
#define DOWNLINK_SEND_IMU_HS_GYRO(_trans, _dev, axis, nb_samples, samples) {}
static inline void pprz_msg_send_IMU_HS_GYRO(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_axis, uint8_t nb_samples, uint32_t *_samples) {}
#define DOWNLINK_SEND_TEST_PASSTHROUGH_STATUS(_trans, _dev, io_proc_msg_cnt, io_proc_err_cnt, io_link_msg_cnt, io_link_err_cnt, rc_status) {}
static inline void pprz_msg_send_TEST_PASSTHROUGH_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_io_proc_msg_cnt, uint32_t *_io_proc_err_cnt, uint32_t *_io_link_msg_cnt, uint32_t *_io_link_err_cnt, uint8_t *_rc_status) {}
#define DOWNLINK_SEND_TUNE_VERT(_trans, _dev, z_sp, est_z, ref_z, ref_zd) {}
static inline void pprz_msg_send_TUNE_VERT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_z_sp, int32_t *_est_z, int32_t *_ref_z, int32_t *_ref_zd) {}
#define DOWNLINK_SEND_MF_DAQ_STATE(_trans, _dev, flight_time, p, q, r, phi, theta, psi, ax, ay, az, ve, vn, vu, lat, lon, alt, we, wn) {}
static inline void pprz_msg_send_MF_DAQ_STATE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_flight_time, float *_p, float *_q, float *_r, float *_phi, float *_theta, float *_psi, float *_ax, float *_ay, float *_az, float *_ve, float *_vn, float *_vu, float *_lat, float *_lon, float *_alt, float *_we, float *_wn) {}
#define DOWNLINK_SEND_INFO_MSG(_trans, _dev, nb_msg, msg) {}
static inline void pprz_msg_send_INFO_MSG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_msg, char *_msg) {}
#define DOWNLINK_SEND_STAB_ATTITUDE_INDI(_trans, _dev, angular_accel_p, angular_accel_q, angular_accel_r, angular_accel_ref_p, angular_accel_ref_q, angular_accel_ref_r, g1_p, g1_q, g1_r, g2_r) {}
static inline void pprz_msg_send_STAB_ATTITUDE_INDI(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_angular_accel_p, float *_angular_accel_q, float *_angular_accel_r, float *_angular_accel_ref_p, float *_angular_accel_ref_q, float *_angular_accel_ref_r, float *_g1_p, float *_g1_q, float *_g1_r, float *_g2_r) {}
#define DOWNLINK_SEND_BEBOP_ACTUATORS(_trans, _dev, cmd_thrust, cmd_roll, cmd_pitch, cmd_yaw, rpm_ref_lf, rpm_ref_rf, rpm_ref_rb, rpm_ref_lb, rpm_obs_lf, rpm_obs_rf, rpm_obs_rb, rpm_obs_lb) {}
static inline void pprz_msg_send_BEBOP_ACTUATORS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, int32_t *_cmd_thrust, int32_t *_cmd_roll, int32_t *_cmd_pitch, int32_t *_cmd_yaw, uint16_t *_rpm_ref_lf, uint16_t *_rpm_ref_rf, uint16_t *_rpm_ref_rb, uint16_t *_rpm_ref_lb, uint16_t *_rpm_obs_lf, uint16_t *_rpm_obs_rf, uint16_t *_rpm_obs_rb, uint16_t *_rpm_obs_lb) {}
#define DOWNLINK_SEND_WEATHER(_trans, _dev, p_amb, t_amb, windspeed, wind_from, humidity) {}
static inline void pprz_msg_send_WEATHER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_p_amb, float *_t_amb, float *_windspeed, float *_wind_from, float *_humidity) {}
#define DOWNLINK_SEND_IMU_TURNTABLE(_trans, _dev, omega) {}
static inline void pprz_msg_send_IMU_TURNTABLE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_omega) {}
#define DOWNLINK_SEND_BARO_RAW(_trans, _dev, abs, diff) {}
static inline void pprz_msg_send_BARO_RAW(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_abs, float *_diff) {}
#define DOWNLINK_SEND_AIR_DATA(_trans, _dev, pressure, diff_p, temp, qnh, amsl_baro, airspeed, tas) {}
static inline void pprz_msg_send_AIR_DATA(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_pressure, float *_diff_p, float *_temp, float *_qnh, float *_amsl_baro, float *_airspeed, float *_tas) {}
#define DOWNLINK_SEND_AMSL(_trans, _dev, AMSL_BARO, AMSL_GPS) {}
static inline void pprz_msg_send_AMSL(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_AMSL_BARO, float *_AMSL_GPS) {}
#define DOWNLINK_SEND_VIDEO_SYNC(_trans, _dev, id) {}
static inline void pprz_msg_send_VIDEO_SYNC(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_id) {}
#define DOWNLINK_SEND_PERIODIC_TELEMETRY_ERR(_trans, _dev, process, mode, id) {}
static inline void pprz_msg_send_PERIODIC_TELEMETRY_ERR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_process, uint8_t *_mode, uint8_t *_id) {}
#define DOWNLINK_SEND_TIME(_trans, _dev, t) {}
static inline void pprz_msg_send_TIME(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_t) {}
#define DOWNLINK_SEND_OPTIC_FLOW_EST(_trans, _dev, fps, corner_cnt, tracked_cnt, flow_x, flow_y, flow_der_x, flow_der_y, vel_x, vel_y, div_size, surface_roughness, divergence) {}
static inline void pprz_msg_send_OPTIC_FLOW_EST(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_fps, uint16_t *_corner_cnt, uint16_t *_tracked_cnt, int16_t *_flow_x, int16_t *_flow_y, int16_t *_flow_der_x, int16_t *_flow_der_y, float *_vel_x, float *_vel_y, float *_div_size, float *_surface_roughness, float *_divergence) {}
#define DOWNLINK_SEND_STEREO_IMG(_trans, _dev, frequency, data_size, nb_imageBuffer, imageBuffer) {}
static inline void pprz_msg_send_STEREO_IMG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_frequency, uint8_t *_data_size, uint8_t nb_imageBuffer, uint8_t *_imageBuffer) {}
#define DOWNLINK_SEND_ROTORCRAFT_STATUS(_trans, _dev, link_imu_nb_err, motor_nb_err, rc_status, frame_rate, gps_status, ap_mode, ap_in_flight, ap_motors_on, ap_h_mode, ap_v_mode, vsupply, cpu_time) {}
static inline void pprz_msg_send_ROTORCRAFT_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_link_imu_nb_err, uint8_t *_motor_nb_err, uint8_t *_rc_status, uint8_t *_frame_rate, uint8_t *_gps_status, uint8_t *_ap_mode, uint8_t *_ap_in_flight, uint8_t *_ap_motors_on, uint8_t *_ap_h_mode, uint8_t *_ap_v_mode, uint16_t *_vsupply, uint16_t *_cpu_time) {}
#define DOWNLINK_SEND_STATE_FILTER_STATUS(_trans, _dev, id, state_filter_mode, value) {}
static inline void pprz_msg_send_STATE_FILTER_STATUS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_id, uint8_t *_state_filter_mode, uint16_t *_value) {}
#define DOWNLINK_SEND_PX4FLOW(_trans, _dev, sensor_id, flow_x, flow_y, flow_comp_m_x, flow_comp_m_y, quality, ground_distance) {}
static inline void pprz_msg_send_PX4FLOW(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_sensor_id, int16_t *_flow_x, int16_t *_flow_y, float *_flow_comp_m_x, float *_flow_comp_m_y, uint8_t *_quality, float *_ground_distance) {}
#define DOWNLINK_SEND_OPTICFLOW(_trans, _dev, flow, ref_alt) {}
static inline void pprz_msg_send_OPTICFLOW(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_flow, float *_ref_alt) {}
#define DOWNLINK_SEND_VISUALTARGET(_trans, _dev, x, y) {}
static inline void pprz_msg_send_VISUALTARGET(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_x, uint16_t *_y) {}
#define DOWNLINK_SEND_SONAR(_trans, _dev, sonar_meas, sonar_distance) {}
static inline void pprz_msg_send_SONAR(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_sonar_meas, float *_sonar_distance) {}
#define DOWNLINK_SEND_PAYLOAD_FLOAT(_trans, _dev, nb_values, values) {}
static inline void pprz_msg_send_PAYLOAD_FLOAT(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t nb_values, float *_values) {}
#define DOWNLINK_SEND_NPS_POS_LLH(_trans, _dev, pprz_lat, lat_geod, lat_geoc, pprz_lon, lon, pprz_alt, alt_geod, agl, asl) {}
static inline void pprz_msg_send_NPS_POS_LLH(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_pprz_lat, float *_lat_geod, float *_lat_geoc, float *_pprz_lon, float *_lon, float *_pprz_alt, float *_alt_geod, float *_agl, float *_asl) {}
#define DOWNLINK_SEND_NPS_RPMS(_trans, _dev, front, back, right, left) {}
static inline void pprz_msg_send_NPS_RPMS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_front, float *_back, float *_right, float *_left) {}
#define DOWNLINK_SEND_NPS_SPEED_POS(_trans, _dev, ltpp_xdd, ltpp_ydd, ltpp_zdd, ltpp_xd, ltpp_yd, ltpp_zd, ltpp_x, ltpp_y, ltpp_z) {}
static inline void pprz_msg_send_NPS_SPEED_POS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_ltpp_xdd, float *_ltpp_ydd, float *_ltpp_zdd, float *_ltpp_xd, float *_ltpp_yd, float *_ltpp_zd, float *_ltpp_x, float *_ltpp_y, float *_ltpp_z) {}
#define DOWNLINK_SEND_NPS_RATE_ATTITUDE(_trans, _dev, p, q, r, phi, theta, psi) {}
static inline void pprz_msg_send_NPS_RATE_ATTITUDE(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_p, float *_q, float *_r, float *_phi, float *_theta, float *_psi) {}
#define DOWNLINK_SEND_NPS_GYRO_BIAS(_trans, _dev, bp, bq, br) {}
static inline void pprz_msg_send_NPS_GYRO_BIAS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_bp, float *_bq, float *_br) {}
#define DOWNLINK_SEND_NPS_RANGE_METER(_trans, _dev, dist) {}
static inline void pprz_msg_send_NPS_RANGE_METER(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_dist) {}
#define DOWNLINK_SEND_NPS_WIND(_trans, _dev, vx, vy, vz) {}
static inline void pprz_msg_send_NPS_WIND(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_vx, float *_vy, float *_vz) {}
#define DOWNLINK_SEND_PPRZ_DEBUG(_trans, _dev, module, errno) {}
static inline void pprz_msg_send_PPRZ_DEBUG(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_module, uint8_t *_errno) {}
#define DOWNLINK_SEND_NPS_ACCEL_LTP(_trans, _dev, xdd, ydd, zdd) {}
static inline void pprz_msg_send_NPS_ACCEL_LTP(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_xdd, float *_ydd, float *_zdd) {}
#define DOWNLINK_SEND_LOOSE_INS_GPS(_trans, _dev, status, time_running, q0, q1, q2, q3, phi, theta, psi, north, east, down, v_north, v_east, v_down, est_p, est_q, est_r, gyroBias_x, gyroBias_y, gyroBias_z, imuCallbacks, gpsCallbacks, baroCallbacks) {}
static inline void pprz_msg_send_LOOSE_INS_GPS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint8_t *_status, double *_time_running, double *_q0, double *_q1, double *_q2, double *_q3, double *_phi, double *_theta, double *_psi, double *_north, double *_east, double *_down, double *_v_north, double *_v_east, double *_v_down, double *_est_p, double *_est_q, double *_est_r, double *_gyroBias_x, double *_gyroBias_y, double *_gyroBias_z, uint32_t *_imuCallbacks, uint32_t *_gpsCallbacks, uint32_t *_baroCallbacks) {}
#define DOWNLINK_SEND_AFL_COEFFS(_trans, _dev, roll_a, roll_b, roll_c, pitch_a, pitch_b, pitch_c, yaw_a, yaw_b, yaw_c) {}
static inline void pprz_msg_send_AFL_COEFFS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_roll_a, float *_roll_b, float *_roll_c, float *_pitch_a, float *_pitch_b, float *_pitch_c, float *_yaw_a, float *_yaw_b, float *_yaw_c) {}
#define DOWNLINK_SEND_I2C_ERRORS(_trans, _dev, wd_reset_cnt, queue_full_cnt, acknowledge_failure_cnt, misplaced_start_or_stop_cnt, arbitration_lost_cnt, overrun_or_underrun_cnt, pec_error_in_reception_cnt, timeout_or_tlow_error_cnt, smbus_alert_cnt, unexpected_event_cnt, last_unexpected_event, bus_number) {}
static inline void pprz_msg_send_I2C_ERRORS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint16_t *_wd_reset_cnt, uint16_t *_queue_full_cnt, uint16_t *_acknowledge_failure_cnt, uint16_t *_misplaced_start_or_stop_cnt, uint16_t *_arbitration_lost_cnt, uint16_t *_overrun_or_underrun_cnt, uint16_t *_pec_error_in_reception_cnt, uint16_t *_timeout_or_tlow_error_cnt, uint16_t *_smbus_alert_cnt, uint16_t *_unexpected_event_cnt, uint32_t *_last_unexpected_event, uint8_t *_bus_number) {}
#define DOWNLINK_SEND_RDYB_TRAJECTORY(_trans, _dev, commanded_phi, commanded_theta, commanded_psi, setpoint_x, setpoint_y, setpoint_z) {}
static inline void pprz_msg_send_RDYB_TRAJECTORY(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, float *_commanded_phi, float *_commanded_theta, float *_commanded_psi, float *_setpoint_x, float *_setpoint_y, float *_setpoint_z) {}
#define DOWNLINK_SEND_HENRY_GNSS(_trans, _dev, last_imu_update, GPS_time, GPS_solution_valid, latitude, longitude, altitude, North, East, Down, SVs_Tracked, SVs_PVT, V_North, V_East, V_Down) {}
static inline void pprz_msg_send_HENRY_GNSS(struct transport_tx *trans, struct link_device *dev, uint8_t ac_id, uint32_t *_last_imu_update, double *_GPS_time, uint8_t *_GPS_solution_valid, double *_latitude, double *_longitude, double *_altitude, double *_North, double *_East, double *_Down, uint8_t *_SVs_Tracked, uint8_t *_SVs_PVT, double *_V_North, double *_V_East, double *_V_Down) {}
#endif // DOWNLINK
#endif // _VAR_MESSAGES_telemetry_H_
